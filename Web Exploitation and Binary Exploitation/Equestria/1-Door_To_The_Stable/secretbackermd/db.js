const { Pool } = require("pg");
const { v4 } = require("uuid");

const pool = new Pool({
  user: process.env.DB_USER || "darklord",
  host: process.env.DB_HOST || "localhost",
  database: process.env.DB_NAME || "darkequestria",
  password: process.env.DB_PASSWORD || "shadowrealm",
  port: parseInt(process.env.DB_PORT || "5432"),
});

const dbAsync = {
  query: (text, params) => pool.query(text, params),
  getClient: () => pool.connect(),
};

const users = [
  {
    username: `lunar-warden-${v4()}`,
    email: "lunar.warden@mail.equestria.mlp",
    notes: [
      "The stars whisper of her return. We must be ready.",
      "Guard the archives wellâ€”secrets must remain hidden.",
      "The nightâ€™s blessing grants us strength beyond the sunâ€™s reach.",
    ],
  },
  {
    username: `shadow-hoof-${v4()}`,
    email: "shadow.hoof@mail.equestria.mlp",
    notes: [
      "The sunâ€™s reign weakens, and soon the night shall rule eternal.",
      "They suspect nothing. The dream realm is our true domain.",
      "Loyalty is not given, it is proven under the cover of darkness.",
    ],
  },
  {
    username: `thestral-veil-${v4()}`,
    email: "thestral.veil@mail.equestria.mlp",
    notes: [
      "In the darkness, our kind thrives. Equestria will remember us.",
      "The night calls to those who listen. Do you hear it?",
      "The Lunar Guard grows stronger in the unseen corners of the realm.",
    ],
  },
  {
    username: `nightmare-moon-${v4()}`,
    email: "nightmare.moon@mail.equestria.mlp",
    notes: [
      "I am the queen of the night, the ruler of the moon. I will rule Equestria.",
      "The Elements of Harmony will not stop me. I will have my revenge.",
      process.env.SECRET_NOTE,
      "The night will last forever.",
    ],
  },
];

// Database setup
async function initDb() {
  try {
    await dbAsync.query(`
      CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY DEFAULT uuid_generate_v4(),
        username TEXT UNIQUE,
        password TEXT,
        email TEXT,
        verified BOOLEAN DEFAULT true
      );
      
      CREATE TABLE IF NOT EXISTS notes (
        id SERIAL PRIMARY KEY,
        user_id TEXT REFERENCES users(id),
        content TEXT
      );
    `);

    for (const user of users) {
      const password = v4();

      const userResult = await dbAsync.query(
        `INSERT INTO users (username, password, email) 
         VALUES ($1, $2, $3)
         RETURNING id`,
        [user.username, password, user.email]
      );

      for (const note of user.notes) {
        await dbAsync.query(
          `INSERT INTO notes (user_id, content) 
           VALUES ($1, $2)`,
          [userResult.rows[0].id, note]
        );
      }

      console.log(`Created user: ${user.username} with password: ${password}`);
    }

    console.log(`ðŸ¦„   (S)Tables have been summoned!`);
    scheduleCleanup(); // Start the cleanup schedule after initialization
  } catch (err) {
    console.error("Failed to summon (s)tables:", err);
    throw err;
  }
}

async function cleanupDatabase() {
  try {
    const validUsernames = users.map((user) => user.username);

    await dbAsync.query(
      `DELETE FROM notes 
       WHERE user_id IN (
         SELECT id FROM users 
         WHERE username != ALL($1)
       )`,
      [validUsernames]
    );

    await dbAsync.query(
      `DELETE FROM users 
       WHERE username != ALL($1)`,
      [validUsernames]
    );

    console.log(
      "ðŸŒ‘ðŸ¦„ Shadows have purged the unauthorized entries from the realm."
    );
  } catch (err) {
    console.error("ðŸŒŒðŸ¦„ The magic faltered while cleansing the database:", err);
  }
}

function scheduleCleanup() {
  cleanupDatabase();
  setInterval(cleanupDatabase, 60000);
}

module.exports = { dbAsync, initDb };
