#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/sha.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

const char *allowed_commands[] = {"ls -la", "whoami", "date",
                                  "uptime", "pwd",    "help"};
#define NUM_ALLOWED_COMMANDS                                                   \
  (sizeof(allowed_commands) / sizeof(allowed_commands[0]))

const char *PUBLIC_KEY_PATH = "/app/keys/pubkey.pem";
const char *PRIVATE_KEY_PATH = "/app/keys/privkey.pem";

void handle_openssl_error() {
  ERR_print_errors_fp(stderr);
  exit(EXIT_FAILURE);
}

RSA *load_public_key(const char *key_path) {
  FILE *fp = fopen(key_path, "r");
  if (!fp) {
    printf("Error opening public key file: %s\n", key_path);
    exit(EXIT_FAILURE);
  }

  RSA *rsa = PEM_read_RSA_PUBKEY(fp, NULL, NULL, NULL);
  fclose(fp);

  if (!rsa) {
    printf("Error reading public key\n");
    handle_openssl_error();
  }

  return rsa;
}

RSA *load_private_key(const char *key_path) {
  FILE *fp = fopen(key_path, "r");
  if (!fp) {
    printf("Error opening private key file: %s\n", key_path);
    return NULL;
  }

  RSA *rsa = PEM_read_RSAPrivateKey(fp, NULL, NULL, NULL);
  fclose(fp);

  if (!rsa) {
    printf("Error reading private key\n");
    handle_openssl_error();
  }

  return rsa;
}

int verify_signature(RSA *rsa, const unsigned char *data, size_t data_len,
                     const unsigned char *signature, size_t sig_len) {
  unsigned char hash[SHA256_DIGEST_LENGTH] = {0};
  SHA256(data, data_len, hash);

  unsigned char *decrypted = malloc(RSA_size(rsa));
  if (!decrypted) {
    printf("Memory allocation failed\n");
    return 0;
  }

  int decrypted_len =
      RSA_public_decrypt(sig_len, signature, decrypted, rsa, RSA_PKCS1_PADDING);

  if (decrypted_len == -1) {
    printf("Signature decryption failed\n");
    handle_openssl_error();
    free(decrypted);
    return 0;
  }

  int result = (decrypted_len == SHA256_DIGEST_LENGTH &&
                strncmp(decrypted, hash, SHA256_DIGEST_LENGTH) == 0);

  free(decrypted);
  return result;
}

unsigned char *decode_base64(const char *b64_data, size_t *out_len) {
  BIO *b64 = BIO_new(BIO_f_base64());
  BIO *bmem = BIO_new_mem_buf(b64_data, -1);
  BIO_push(b64, bmem);
  BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);

  size_t length = strlen(b64_data);
  unsigned char *buffer = malloc(length);
  *out_len = BIO_read(b64, buffer, length);

  BIO_free_all(b64);
  return buffer;
}

char *base64_encode(const unsigned char *input, int length) {
  BIO *bmem, *b64;
  BUF_MEM *bptr;

  b64 = BIO_new(BIO_f_base64());
  BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
  bmem = BIO_new(BIO_s_mem());
  b64 = BIO_push(b64, bmem);
  BIO_write(b64, input, length);
  BIO_flush(b64);
  BIO_get_mem_ptr(b64, &bptr);

  char *buff = malloc(bptr->length + 1);
  memcpy(buff, bptr->data, bptr->length);
  buff[bptr->length] = 0;

  BIO_free_all(b64);
  return buff;
}

char *sign_command(RSA *rsa, const char *command) {
  unsigned char hash[SHA256_DIGEST_LENGTH];
  SHA256((unsigned char *)command, strlen(command), hash);

  // printf("Hash for command '%s' is: ", command);
  // for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
  //   printf("%02x", hash[i]);
  // }

  unsigned char *encrypted = malloc(RSA_size(rsa));
  if (!encrypted) {
    printf("Memory allocation failed\n");
    return NULL;
  }

  int encrypted_len = RSA_private_encrypt(SHA256_DIGEST_LENGTH, hash, encrypted,
                                          rsa, RSA_PKCS1_PADDING);

  if (encrypted_len == -1) {
    printf("Failed to encrypt hash\n");
    handle_openssl_error();
    free(encrypted);
    return NULL;
  }

  char *result = base64_encode(encrypted, encrypted_len);
  free(encrypted);
  return result;
}

void generate_key_pair() {
  RSA *rsa = RSA_new();
  BIGNUM *bn = BN_new();
  BN_set_word(bn, RSA_F4);

  if (RSA_generate_key_ex(rsa, 2048, bn, NULL) != 1) {
    printf("Failed to generate RSA key pair\n");
    handle_openssl_error();
    RSA_free(rsa);
    BN_free(bn);
    return;
  }

  FILE *private_key_file = fopen(PRIVATE_KEY_PATH, "w");
  if (!private_key_file) {
    printf("Failed to open private key file for writing\n");
    RSA_free(rsa);
    BN_free(bn);
    return;
  }

  if (!PEM_write_RSAPrivateKey(private_key_file, rsa, NULL, NULL, 0, NULL,
                               NULL)) {
    printf("Failed to write private key to file\n");
    handle_openssl_error();
  }
  fclose(private_key_file);

  FILE *public_key_file = fopen(PUBLIC_KEY_PATH, "w");
  if (!public_key_file) {
    printf("Failed to open public key file for writing\n");
    RSA_free(rsa);
    BN_free(bn);
    return;
  }

  if (!PEM_write_RSA_PUBKEY(public_key_file, rsa)) {
    printf("Failed to write public key to file\n");
    handle_openssl_error();
  }
  fclose(public_key_file);

  printf("RSA key pair generated successfully.\n");

  RSA_free(rsa);
  BN_free(bn);
}

void display_help() {
  printf("Available commands:\n");

  RSA *rsa = load_private_key(PRIVATE_KEY_PATH);
  if (!rsa) {
    printf("Failed to load private key. Generating new key pair...\n");
    generate_key_pair();
    rsa = load_private_key(PRIVATE_KEY_PATH);
    if (!rsa) {
      printf("Still can't load private key. Exiting.\n");
      return;
    }
  }

  for (size_t i = 0; i < NUM_ALLOWED_COMMANDS; i++) {
    if (strcmp(allowed_commands[i], "help") == 0 ||
        strcmp(allowed_commands[i], "exit") == 0) {
      continue;
    }
    char *signature = sign_command(rsa, allowed_commands[i]);
    printf("%s\n    Signature: %s\n\n", allowed_commands[i], signature);
    free(signature);
  }

  RSA_free(rsa);
}

char *read_line() {
  char *line = NULL;
  size_t len = 0;
  ssize_t read;

  read = getline(&line, &len, stdin);

  if (read == -1) {
    free(line);
    return NULL;
  }

  if (line[read - 1] == '\n') {
    line[read - 1] = '\0';
  }

  return line;
}

void interactive_mode() {
  RSA *rsa = load_public_key(PUBLIC_KEY_PATH);
  if (!rsa) {
    printf("Public key not found. Generating new key pair...\n");
    generate_key_pair();
    rsa = load_public_key(PUBLIC_KEY_PATH);
    if (!rsa) {
      printf("Still can't load public key. Exiting.\n");
      return;
    }
  }

  printf("RSA Command Verifier - Interactive Mode\n");
  printf("Enter 'exit' to quit\n");
  printf("Enter 'help' for a list of available commands\n");

  while (1) {
    printf("\nCommand: ");
    char *command = read_line();

    if (!command) {
      printf("Error reading command\n");
      break;
    }

    if (strcmp(command, "exit") == 0) {
      free(command);
      break;
    }

    if (strcmp(command, "help") == 0) {
      free(command);
      display_help();
      continue;
    }

    printf("Signature: ");
    char *b64_signature = read_line();

    if (!b64_signature) {
      printf("Error reading signature\n");
      free(command);
      break;
    }

    size_t sig_len;
    unsigned char *signature = decode_base64(b64_signature, &sig_len);

    if (verify_signature(rsa, (unsigned char *)command, strlen(command),
                         signature, sig_len)) {
      printf("Signature verified. Executing command: %s\n", command);
      system(command);
    } else {
      printf("Invalid signature. Command will not be executed.\n");
    }

    free(command);
    free(b64_signature);
    free(signature);
  }

  RSA_free(rsa);
}

int main(int argc, char *argv[]) {
  OpenSSL_add_all_algorithms();
  ERR_load_crypto_strings();

  if (argc > 1) {
    if (strcmp(argv[1], "help") == 0) {
      display_help();
    } else if (strcmp(argv[1], "regen-keys") == 0) {
      generate_key_pair();
    } else if (strcmp(argv[1], "interactive") == 0) {
      interactive_mode();
    } else {
      printf("Invalid argument: %s\n", argv[1]);
      printf("Usage: %s [help|regen-keys|interactive]\n", argv[0]);
      printf("Run without arguments for interactive mode\n");
      EVP_cleanup();
      ERR_free_strings();
      return EXIT_FAILURE;
    }
  } else {
    interactive_mode();
  }

  EVP_cleanup();
  ERR_free_strings();
  return EXIT_SUCCESS;
}
