# Zadanie

EN: Greg didn’t ask for this. Greg wanted a quiet Friday, maybe a donut, and ideally no malware. But no. Instead, Greg found logs—weird logs. And when Greg sees weird logs, Greg investigates. This is Greg’s story.

############

Analyst Log – 09:14 AM: "They called it a 'low-priority anomaly.' Said it was probably nothing. That’s what they always say before things explode". I ran strings on the file—didn’t like what I saw. Not an update. Not even ransomware. Just… vibes. Binary vibes. They’ve named it internally ‘SystemUpdate.’ I don’t know why. No update was done. I’m not even sure if this is about system update anymore.

############

SK: Greg o toto nežiadal. Greg chcel pokojný piatok, možno šišku, a ideálne žiadny malvér. Ale nie. Namiesto toho našiel logy – čudné logy. A keď Greg vidí čudné logy, Greg vyšetruje. Toto je Gregov príbeh.

############

Záznam analytika – 09:14 : „Nazvali to 'nízkoprioritná anomália.' Vraj to bude asi nič. To hovoria vždy, kým to celé nevybuchne.“ Spustil som strings na tom súbore – nepáčilo sa mi, čo som videl. Nebola to aktualizácia. Ani ransomvér. Len... pocit. Binárny pocit. Interné označenie má ‘SystemUpdate’. Netuším prečo. Žiadna aktualizácia neprebehla. Už si ani nie som istý, či to celé vôbec ešte súvisí so systémom.

############

**Súbory:**

- system_update

## Riešenie

Pokúšal som sa spustiť binárku, ale zakaždým segmentation fault, tak som to rýchlo vzdal a začal so statickou analýzou v ghidre.

Analýza prešla, pseudokód vygenerovaný, žiadne symboly nie sú, nevadí, začnem na entry a pozrem volania

```c

void processEntry entry(undefined8 param_1,undefined8 param_2)

{
  undefined auStack_8 [8];
  
  __libc_start_main(FUN_00101210,param_2,&stack0x00000008,0,0,param_1,auStack_8);
  do {
                    /* WARNING: Do nothing block with infinite loop */
  } while( true );
}


```

libc volá `FUN_00101210`, pozriem dnu.

```c

undefined8 FUN_00101210(undefined8 param_1,long param_2)

{
  FUN_001020c0();
  DAT_00105260 = *(undefined8 *)(param_2 + 8);
  (**(code **)(&DAT_00105140 + (long)DAT_00105204 * 8))();
  return 0;
}


```

Tu je jediné volanie na `FUN_001020c0`. 

```c

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void FUN_001020c0(void)

{
  _DAT_00105140 = FUN_00101340;
  pcRam0000000000105148 = FUN_00101390;
  _DAT_00105150 = FUN_001013e0;
  pcRam0000000000105158 = FUN_00101980;
  _DAT_00105160 = FUN_00101430;
  pcRam0000000000105168 = FUN_001017a0;
  _DAT_00105170 = FUN_001017f0;
  pcRam0000000000105178 = FUN_001019d0;
  _DAT_00105180 = FUN_00101840;
  pcRam0000000000105188 = FUN_00101890;
  _DAT_00105190 = FUN_00101a20;
  pcRam0000000000105198 = FUN_001018e0;
  _DAT_001051a0 = FUN_00101930;
  pcRam00000000001051a8 = FUN_00101480;
  _DAT_001051b0 = FUN_001014d0;
  pcRam00000000001051b8 = FUN_00101520;
  _DAT_001051c0 = FUN_00101570;
  pcRam00000000001051c8 = FUN_001015c0;
  _DAT_001051d0 = FUN_00101610;
  pcRam00000000001051d8 = FUN_00101660;
  _DAT_001051e0 = FUN_001016b0;
  pcRam00000000001051e8 = FUN_00101700;
  _DAT_001051f0 = FUN_00101750;
  pcRam00000000001051f8 = FUN_00102030;
  return;
}


```

Tu som preklikal všetko, vyzerá tona nejake obfuskovacie funkcie a len posledná `FUN_00102030` niečo volá ďalej..

```c

void FUN_00102030(void)

{
  long lVar1;
  long lVar2;
  
  lVar2 = (long)DAT_00105200;
  DAT_00105200 = DAT_00105200 + 1;
  lVar1 = (long)DAT_00105200;
  (&DAT_00105220)[lVar2] = -*(char *)(DAT_00105260 + lVar2) - 0x10U ^ 0x5c;
  (&DAT_00105220)[lVar1] = 0;
  FUN_00101f50();
  return;
}


```

Táto teda volá `FUN_00101f50`, tak idem dnu.

```c
void FUN_00101f50(void)

{
  char *__buf;
  int __fd;
  int iVar1;
  long lVar2;
  size_t __n;
  ssize_t sVar3;
  sockaddr local_28;
  
  __fd = socket(2,1,0);
  if (-1 < __fd) {
    local_28.sa_family = 2;
    local_28.sa_data[0] = 0x1b;
    local_28.sa_data[1] = 0x8c;
    iVar1 = inet_pton(2,"195.168.112.4",local_28.sa_data + 2);
    if ((0 < iVar1) && (iVar1 = connect(__fd,&local_28,16), __buf = DAT_00105260, -1 < iVar1)) {
      lVar2 = 0;
      do {
        if ((&DAT_00105220)[lVar2] != (&DAT_001050f0)[lVar2]) {
          return;
        }
        lVar2 = lVar2 + 1;
      } while (lVar2 != 24);
      __n = strlen(DAT_00105260);
      sVar3 = send(__fd,__buf,__n,0);
      if (-1 < sVar3) {
        FUN_00101e70();
        close(__fd);
        return;
      }
    }
    close(__fd);
  }
                    /* WARNING: Subroutine does not return */
  exit(1);
}


```

A tu už je niečo zaujímavé. Známa IP adresa, konkrétne tá, na ktorej je `exp.cybergame.sk` , port je ukrytý v `local_28.sa_data`, sú to dva bajty a spolu sú `0x1b8c`, čo je `7052`. Ďalej dochádza k porovnaniu 24 bajtov na adresách `DAT_00105220` a `DAT_001050f0`. Ak nájde akýkoľvek rozdiel, funkcia okamžite skončí bez ďalšej akcie. Ak sa predchádzajúce dáta zhodovali, vypočíta sa dĺžka textu v `DAT_00105260` a tento text (`__buf`) sa odošle cez pripojený socket na server. Program, teda očakáva nejaký argument pri spustení a teda zrejme vlajku, ktorá sa obfuskuje týmu funkciami vyššie a keď sa obfuskovaná vlajka zhoduje v bytearray v `&DAT_001050f0`. To obsahuje len jeden bajt, konkrétne `0xf9`

```
                             DAT_001050f0                                    XREF[2]:     FUN_00101f50:00101fb5(*), 
                                                                                          FUN_00101f50:00101fca(R)  
        001050f0 f9              undefined1 F9h
```

Potrebujeme 24 bajtov, ale na adrese za touto je 23 bajtov..

```
                             DAT_001050f1                                    XREF[1]:     FUN_00101f50:00101fca(R)  
        001050f1 ff              undefined1 FFh
        001050f2 8f              ??         8Fh
        001050f3 e0              ??         E0h
        001050f4 ea              ??         EAh
        001050f5 c6              ??         C6h
        001050f6 fe              ??         FEh
        001050f7 2a              ??         2Ah    *
        001050f8 cc              ??         CCh
        001050f9 9d              ??         9Dh
        001050fa e6              ??         E6h
        001050fb 9a              ??         9Ah
        001050fc 92              ??         92h
        001050fd d3              ??         D3h
        001050fe c4              ??         C4h
        001050ff cb              ??         CBh
        00105100 20              ??         20h     
        00105101 e1              ??         E1h
        00105102 df              ??         DFh
        00105103 d7              ??         D7h
        00105104 95              ??         95h
        00105105 e0              ??         E0h
        00105106 cc              ??         CCh
        00105107 2f              ??         2Fh    /

```

`f9 ff 8f e0 ea c6 fe 2a cc 9d e6 9a 92 d3 c4 cb 20 e1 df d7 95 e0 cc 2f `



Potrebujeme nájsť taký vstup, ktorý sa po transformácii stane týmto na adrese `DAT_00105220` a porovná sa s `DAT_001050f0`. Vrátil som sa o pár krokov späť a zistil som, že každá s tých funckií predtým obfuskovala po jendom bajte. Konkrétne v takotmto poradí a takto..

| Funkcia        | Transformácia bajtu     |
| -------------- | ----------------------- |
| `FUN_00101340` | `-(char) - 8 ^ 0x5c`    |
| `FUN_00101390` | `-(char) - 0x12 ^ 0x5c` |
| `FUN_001013e0` | `-(char) ^ 0x5c`        |
| `FUN_00101430` | `-(char) - 5 ^ 0x5c`    |
| `FUN_00101480` | `-(char) - 3 ^ 0x5c`    |
| `FUN_001014d0` | `(char) ^ 0xa3`         |
| `FUN_00101520` | `-(char) - 10 ^ 0x5c`   |
| `FUN_00101570` | `-(char) - 0x14 ^ 0x5c` |
| `FUN_001015c0` | `-(char) - 0xf ^ 0x5c`  |
| `FUN_00101610` | `-(char) - 4 ^ 0x5c`    |
| `FUN_00101660` | `-(char) - 9 ^ 0x5c`    |
| `FUN_001016b0` | `-(char) - 7 ^ 0x5c`    |
| `FUN_00101700` | `-(char) - 0x10 ^ 0x5c` |
| `FUN_00101750` | `-(char) - 0xc ^ 0x5c`  |
| `FUN_001017a0` | `-(char) - 0x14 ^ 0x5c` |
| `FUN_001017f0` | `-(char) - 10 ^ 0x5c`   |
| `FUN_00101840` | `-(char) - 9 ^ 0x5c`    |
| `FUN_00101890` | `-(char) - 0xc ^ 0x5c`  |
| `FUN_001018e0` | `-(char) - 3 ^ 0x5c`    |
| `FUN_00101930` | `(char) ^ 0xa3`         |
| `FUN_00101980` | `(char) ^ 0xa3`         |
| `FUN_001019d0` | `-(char) - 0xf ^ 0x5c`  |
| `FUN_00101a20` | `-(char) - 0xf ^ 0x5c`  |
| `FUN_00102030` | `-(char) - 0x10 ^ 0x5c` |

Každá z týchto funkcií zapíše jeden obfuskovaný bajt do poľa na `DAT_00105220`.

Takýto python skript, ktorý otočí obfuskačnú logiku na deobfuskáciu nám postačí.

```python
data = [0xf9, 0xff, 0x8f, 0xe0, 0xea, 0xc6, 0xfe, 0x2a,
        0xcc, 0x9d, 0xe6, 0x9a, 0x92, 0xd3, 0xc4, 0xcb,
        0x20, 0xe1, 0xdf, 0xd7, 0x95, 0xe0, 0xcc, 0x2f]

ops_reversed = [
    lambda y: (-((y ^ 0x5c) + 8)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0x12)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0)) & 0xff,
    lambda y: (y ^ 0xa3) & 0xff,  # XOR je symetrický
    lambda y: (-((y ^ 0x5c) + 5)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0x14)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 10)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0xf)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 9)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0xc)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0xf)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 3)) & 0xff,
    lambda y: (y ^ 0xa3) & 0xff,  # XOR je symetrický
    lambda y: (-((y ^ 0x5c) + 3)) & 0xff,
    lambda y: (y ^ 0xa3) & 0xff,  # XOR je symetrický
    lambda y: (-((y ^ 0x5c) + 10)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0x14)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0xf)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 4)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 9)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 7)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0x10)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0xc)) & 0xff,
    lambda y: (-((y ^ 0x5c) + 0x10)) & 0xff,
]

decrypted = bytes([op(byte) for byte, op in zip(data, ops_reversed)])
print(decrypted)

```

Výstup bude

`SK-CERT{g3771ng_p4yl04d}`



## Vlajka

```
SK-CERT{g3771ng_p4yl04d}
```
